<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DOOFYTALE - The Game</title>
    <!-- Tailwind CSS CDN for utility-first styling (for general box styles) -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Font Awesome for icons (still useful for general icons if needed) -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <!-- Google Fonts import for 'Press Start 2P' (pixel art - for specific retro elements) -->
    <link href="https://fonts.googleapis.com/css2?family=Press+Start 2P&display=swap" rel="stylesheet">
    <!-- Tone.js for Web Audio API -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js"></script>
    <style>
        /* Global Styles for Pixel Art Theme with Modern Touch */
        body {
            font-family: 'Press Start 2P', cursive; /* Pixel font for most text */
            background-color: #0d0d0d; /* Slightly softer black for pixel feel */
            color: #e0e0e0; /* Off-white for text, softer contrast */
            image-rendering: optimizeSpeed;
            image-rendering: -moz-crisp-edges;
            image-rendering: -webkit-optimize-contrast;
            image-rendering: pixelated;
            -ms-interpolation-mode: nearest-neighbor;
            line-height: 1.6; /* Improved readability for pixel font */
            overflow: hidden; /* Hide scrollbars */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        /* Text shadow for readability on pixel fonts */
        .text-shadow-pixel {
            text-shadow: 1px 1px 0px rgba(0, 0, 0, 0.6); /* Softer shadow */
        }

        /* Heart shape for player soul - adjusted for pixelated look */
        .heart {
            width: 36px; /* Slightly larger */
            height: 36px;
            background-color: #ff0000; /* Vibrant red */
            transform: rotate(45deg);
            position: relative;
            animation: pulse-pixel 1.2s infinite steps(2); /* Stepped pulse for pixel feel */
            box-shadow: 0 0 0 1px #000000, 0 0 0 4px #ff0000; /* Enhanced pixelated glow effect, softer borders */
            border-radius: 0; /* Sharp corners */
        }
        
        .heart:before, .heart:after {
            content: "";
            width: 36px; /* Slightly larger */
            height: 36px;
            background-color: #ff0000;
            border-radius: 0; /* Sharp corners */
            position: absolute;
            box-shadow: 0 0 0 1px #000000; /* Pixelated border for heart parts, softer */
        }
        
        .heart:before {
            top: -18px; /* Adjusted for new size */
            left: 0;
        }
        
        .heart:after {
            top: 0;
            left: -18px; /* Adjusted for new size */
        }
        
        /* Keyframes for the pixelated heart pulse animation */
        @keyframes pulse-pixel {
            0% { transform: rotate(45deg) scale(1); }
            50% { transform: rotate(45deg) scale(1.1); }
            100% { transform: rotate(45deg) scale(1); }
        }
        
        /* Soul animation for floating effect */
        .soul-animation {
            animation: float-pixel 2.5s ease-in-out infinite steps(2); /* Stepped float */
        }
        
        /* Keyframes for the pixelated floating animation */
        @keyframes float-pixel {
            0% { transform: translateY(0px); }
            50% { transform: translateY(-14px); } /* Slightly larger vertical movement */
            100% { transform: translateY(0px); }
        }
        
        /* Styling for game UI boxes - very blocky and high contrast */
        .game-box {
            border: 3px solid #b0b0b0; /* Thicker, softer white border */
            box-shadow: 5px 5px 0px rgba(0, 0, 0, 0.7); /* Softer, less offset pixel shadow */
            background-color: rgba(10, 10, 10, 0.9); /* Slightly transparent dark background */
            border-radius: 6px; /* Subtle rounded corners */
            padding: 1.4rem; /* Consistent padding */
        }
        
        /* Styling for dialogue boxes - pixelated with modern blur */
        .dialogue-box {
            border: 2px solid #808080; /* Thicker, softer border */
            background-color: rgba(10,10,10,0.9); /* More subtle transparency */
            padding: 1.7rem; /* Increased padding */
            border-radius: 8px; /* Slightly more rounded corners */
            box-shadow: 4px 4px 0px rgba(0,0,0,0.4); /* Softer shadow */
            z-index: 999;
            backdrop-filter: blur(6px); /* Slightly more blur */
            -webkit-backdrop-filter: blur(6px); /* For Safari */
            animation: fadeInUp 0.4s ease-out forwards; /* Dialogue box entry animation */
            cursor: pointer; /* Indicate clickable to skip text */
        }

        /* Keyframes for dialogue box fade in from bottom */
        @keyframes fadeInUp {
            from { opacity: 0; transform: translate(-50%, 25px); } /* Larger initial offset */
            to { opacity: 1; transform: translate(-50%, 0); }
        }
        
        /* Button styling for a retro, clickable feel with smooth transitions */
        .game-button {
            background-color: rgba(25, 25, 25, 0.95); /* Darker, slightly transparent background */
            color: #e8e8e8; /* Off-white text */
            border: 2px solid #808080; /* Thicker, softer border */
            box-shadow: 3px 3px 0px rgba(0, 0, 0, 0.5); /* Softer shadow */
            transition: all 0.1s ease-out; /* Smoother transition */
            border-radius: 6px; /* Subtle rounded corners */
            cursor: pointer; /* Standard cursor for modern feel */
            text-transform: uppercase; /* All caps for buttons */
            padding: 0.8rem 1.6rem; /* Increased button padding */
            font-family: 'Press Start 2P', cursive; /* Pixel font for buttons */
            font-size: 1rem; /* Slightly larger font for subtlety */
        }

        .game-button:hover {
            background-color: rgba(40, 40, 40, 0.98); /* Slightly lighter on hover */
            color: #ffffff; /* Pure white on hover */
            box-shadow: 2px 2px 0px rgba(0, 0, 0, 0.7); /* Pressed pixel button effect */
            transform: translate(2px, 2px); /* Simulate press */
        }

        .game-button:active {
            background-color: #555555; /* Darker when active */
            box-shadow: 0 0 0px #000000;
            transform: translate(3px, 3px);
        }
        
        /* Responsive adjustments - Mobile First */
        /* Default styles are for mobile */
        .text-5xl { font-size: 2.5rem; } /* Hero title */
        .text-7xl { font-size: 3.5rem; } /* Character icons */
        .text-8xl { font-size: 4rem; } /* Hero title on larger mobile */
        .text-xl { font-size: 1rem; } /* General headings/larger text */
        .text-lg { font-size: 0.9rem; } /* Body text */
        .text-base { font-size: 0.8rem; } /* Smaller body text */
        .text-sm { font-size: 0.7rem; } /* Smallest text */
        .text-xs { font-size: 0.5rem; } /* Very small text */

        /* Heart size for mobile */
        .heart { width: 24px; height: 24px; }
        .heart:before, .heart:after { width: 24px; height: 24px; top: -12px; left: -12px; }

        /* Small devices (sm) - 640px and up */
        @media (min-width: 640px) {
            .text-5xl { font-size: 3.2rem; }
            .text-7xl { font-size: 4.2rem; }
            .text-8xl { font-size: 5rem; }
            .text-xl { font-size: 1.1rem; }
            .text-lg { font-size: 1rem; }
            .text-base { font-size: 0.9rem; }
            .text-sm { font-size: 0.8rem; }
            .text-xs { font-size: 0.6rem; }
            .heart { width: 28px; height: 28px; }
            .heart:before, .heart:after { width: 28px; height: 28px; top: -14px; left: -14px; }
        }

        /* Medium devices (md) - 768px and up */
        @media (min-width: 768px) {
            .text-5xl { font-size: 3.8rem; }
            .text-7xl { font-size: 5rem; }
            .text-8xl { font-size: 6rem; }
            .text-xl { font-size: 1.2rem; }
            .text-lg { font-size: 1.1rem; }
            .text-base { font-size: 1rem; }
            .text-sm { font-size: 0.9rem; }
            .text-xs { font-size: 0.7rem; }
            .heart { width: 32px; height: 32px; }
            .heart:before, .heart:after { width: 32px; height: 32px; top: -16px; left: -16px; }
        }

        /* Large devices (lg) - 1024px and up */
        @media (min-width: 1024px) {
            .text-5xl { font-size: 4.5rem; }
            .text-7xl { font-size: 6rem; }
            .text-8xl { font-size: 7rem; }
            .text-xl { font-size: 1.3rem; }
            .text-lg { font-size: 1.2rem; }
            .text-base { font-size: 1.1rem; }
            .text-sm { font-size: 1rem; }
            .text-xs { font-size: 0.8rem; }
        }

        /* Extra large devices (xl) - 1280px and up */
        @media (min-width: 1280px) {
            .text-5xl { font-size: 5rem; }
            .text-7xl { font-size: 7rem; }
            .text-8xl { font-size: 8rem; }
        }

        /* Game specific styles */
        #game-container {
            display: flex;
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 100;
            background-color: #0d0d0d; /* Match body background */
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        #gameCanvas {
            display: block;
            margin: 0 auto;
            background: #000; /* Pure black for canvas */
            image-rendering: pixelated;
            border: 3px solid #b0b0b0; /* Thicker, softer white pixel border */
            border-radius: 6px; /* Subtle rounded corners */
            box-shadow: 5px 5px 0px rgba(0, 0, 0, 0.7); /* Strong pixel shadow */
            overflow: hidden;
            cursor: none; /* Hide default mouse cursor during gameplay */
            animation: dodge-box-glow 2s infinite alternate; /* Subtle glow */
        }

        /* Keyframes for dodge box glow */
        @keyframes dodge-box-glow {
            from { box-shadow: 5px 5px 0px rgba(0, 0, 0, 0.7), 0 0 6px rgba(255, 255, 255, 0.15); } /* Softer glow */
            to { box-shadow: 5px 5px 0px rgba(0, 0, 0, 0.7), 0 0 12px rgba(255, 255, 255, 0.4); } /* Softer glow */
        }

        #dialogueBox {
            position: absolute;
            bottom: 25px; /* More space from bottom */
            left: 50%;
            transform: translateX(-50%);
            width: 95%; /* Wider dialogue box for better text flow */
            max-width: 750px; /* Slightly wider max width */
            /* Styles defined in .dialogue-box */
            display: none; /* Handled by JS */
            box-sizing: border-box;
        }

        #dialogueText {
            font-size: 18px; /* Pixel font size for dialogue */
            margin-bottom: 12px; /* Increased margin */
            white-space: pre-line; /* Allows newlines and wraps text */
            min-height: 54px; /* Ensure space for lines of text */
            text-align: left;
            padding-left: 10px; /* Slightly less padding */
            color: #e0e0e0; /* Softer text color */
            font-family: 'Press Start 2P', cursive;
            position: relative; /* For blinking cursor */
        }

        #dialogueText::after {
            content: '_'; /* Blinking cursor */
            animation: blink-caret 0.75s step-end infinite;
            font-weight: bold;
            color: #e0e0e0; /* Softer cursor color */
            position: absolute;
            bottom: 0;
            right: -5px; /* Adjust position */
            display: inline-block; /* Ensure it's visible next to text */
        }

        @keyframes blink-caret {
            from, to { opacity: 0; }
            50% { opacity: 1; }
        }

        #options {
            display: flex;
            justify-content: center; /* Center buttons */
            flex-wrap: wrap;
            gap: 12px; /* Increased space between buttons for compact look */
            width: 100%;
            padding-top: 12px; /* Increased padding */
            border-top: 2px solid rgba(255,255,255,0.15); /* Subtle separator */
        }

        #options .optionButton {
            /* Inherits most styles from .game-button */
            flex-grow: 0; /* Don't force growth */
            min-width: 140px; /* Minimum width for buttons */
            max-width: 200px; /* Max width for buttons, increased for "Determination" */
            font-size: 14px; /* Slightly smaller font for options, to fit text */
            padding: 12px 18px; /* Increased padding */
            text-align: center;
        }

        #options .optionButton:hover {
            transform: translate(2px, 2px);
        }
        #options .optionButton:active {
            transform: translate(3px, 3px);
        }

        /* Specific styles for the game's main menu */
        #game-main-menu {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            width: 100%;
            height: 100%;
            position: absolute;
            top: 0;
            left: 0;
            background-color: rgba(10, 10, 10, 0.98); /* Darker, more opaque overlay */
            z-index: 101;
            /* No animation here, controlled by JS */
        }

        #game-main-menu h2 {
            font-family: 'Press Start 2P', cursive; /* Keep pixel font for title */
            font-size: 5rem; /* Larger title */
            color: #ffffff; /* White title */
            margin-bottom: 50px; /* Increased margin */
            text-shadow: 4px 4px 0px rgba(0, 0, 0, 0.6), 0 0 18px rgba(255, 255, 255, 0.6); /* Stronger pixel shadow with glow */
        }

        #game-main-menu button {
            margin-bottom: 20px; /* Increased margin */
            padding: 15px 30px; /* Increased padding */
            font-size: 22px; /* Slightly larger font */
            /* Inherits styles from .game-button */
        }

        /* Floating Text for Hit/Miss Indicators */
        .floating-text {
            position: absolute;
            font-family: 'Press Start 2P', cursive;
            font-size: 22px; /* Slightly larger */
            font-weight: bold;
            color: yellow; /* Default color, can be overridden */
            opacity: 1;
            animation: floatUpFadeOut 1.2s forwards; /* Longer float duration */
            pointer-events: none; /* Do not block clicks */
            text-shadow: 2px 2px 0px black; /* Softer shadow */
            z-index: 1000;
        }

        @keyframes floatUpFadeOut {
            0% { transform: translateY(0); opacity: 1; }
            100% { transform: translateY(-60px); opacity: 0; } /* Longer float */
        }

        /* Bullet Tutorial Box */
        #bulletTutorialBox {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 90%;
            max-width: 600px; /* Slightly wider */
            background-color: rgba(10,10,10,0.9); /* Softer background */
            border: 2px solid #808080; /* Thicker, softer border */
            padding: 25px; /* Increased padding */
            border-radius: 8px; /* Rounded corners */
            box-shadow: 4px 4px 0px rgba(0,0,0,0.4); /* Softer shadow */
            z-index: 1000;
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            backdrop-filter: blur(6px);
            -webkit-backdrop-filter: blur(6px);
        }

        #bulletTutorialBox h3 {
            font-size: 22px; /* Slightly larger */
            margin-bottom: 20px; /* Increased margin */
            color: #ffd700; /* Gold color for title */
        }

        #bulletTutorialBox .tutorial-item {
            display: flex;
            align-items: center;
            margin-bottom: 15px; /* Increased margin */
            gap: 15px; /* Increased gap */
        }

        #bulletTutorialBox .tutorial-bullet-example {
            width: 40px; /* Slightly larger */
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 30px; /* Slightly larger */
            border: 2px solid #b0b0b0; /* Softer border */
            background-color: #282828; /* Softer background */
            border-radius: 4px; /* Subtle rounded corners */
        }

        #bulletTutorialBox .tutorial-text {
            font-size: 16px; /* Slightly larger */
            text-align: left;
            flex-grow: 1;
            color: #e0e0e0; /* Softer text color */
        }

        #bulletTutorialBox button {
            margin-top: 20px; /* Increased margin */
        }

    </style>
</head>
<body class="bg-black text-white min-h-screen">
    <!-- Game Container -->
    <div id="game-container">
        <div id="game-main-menu">
            <h2 class="font-pixel text-shadow-pixel">DOOFYTALE</h2>
            <button id="menu-play-button" class="game-button">PLAY</button>
            <button id="menu-options-button" class="game-button">OPTIONS</button>
            <button id="menu-credits-button" class="game-button">CREDITS</button>
            <button id="menu-exit-button" class="game-button">EXIT</button>
        </div>

        <canvas id="gameCanvas"></canvas> <!-- Width/Height set by JS -->
        <div id="dialogueBox" class="dialogue-box">
            <div id="dialogueText"></div>
            <div id="options"></div>
        </div>

        <!-- Bullet Tutorial Box -->
        <div id="bulletTutorialBox">
            <h3>HOW TO DODGE!</h3>
            <div class="tutorial-item">
                <div class="tutorial-bullet-example" style="background-color: #dc2626;">‚ù§Ô∏è</div>
                <div class="tutorial-text">
                    <span style="color: #ef4444;">RED BULLETS:</span> Move your soul to dodge!
                </div>
            </div>
            <div class="tutorial-item">
                <div class="tutorial-bullet-example" style="background-color: #3b82f6;">üíô</div>
                <div class="tutorial-text">
                    <span style="color: #60a5fa;">BLUE BULLETS:</span> Stop moving (stay still) to dodge!
                </div>
            </div>
            <div class="tutorial-item">
                <div class="tutorial-bullet-example" style="background-color: #f97316;">üß°</div>
                <div class="tutorial-text">
                    <span style="color: #fb923c;">ORANGE BULLETS:</span> Move your soul to dodge! (They pass through if you're moving!)
                </div>
            </div>
            <button id="tutorialContinueBtn" class="game-button">GOT IT!</button>
        </div>
    </div>

    <script>
        // --- Custom Message Box (replaces alert) ---
        function showCustomMessage(message) {
            // Pause the game when a custom message appears
            isGamePausedForPopup = true;

            const messageBox = document.createElement('div');
            messageBox.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background-color: rgba(10, 10, 10, 0.95); /* Softer, more opaque */
                border: 2px solid #808080; /* Softer border */
                padding: 25px; /* Increased padding */
                color: #e0e0e0; /* Softer text color */
                font-family: 'Press Start 2P', cursive; /* Pixel font for message box */
                text-align: center;
                z-index: 1000;
                box-shadow: 4px 4px 0px rgba(0,0,0,0.4); /* Softer shadow */
                border-radius: 8px; /* Rounded corners */
                max-width: 450px; /* Slightly wider */
                animation: fadeIn 0.3s ease-out;
                backdrop-filter: blur(6px);
                -webkit-backdrop-filter: blur(6px);
            `;
            messageBox.innerHTML = `
                <p class="text-lg mb-4">${message}</p>
                <button class="game-button px-6 py-3 text-base" style="display: inline-block;">OK</button>
            `;
            document.body.appendChild(messageBox);

            // Disable and fade menu buttons while message is active
            const menuButtons = gameMainMenu.querySelectorAll('button');
            menuButtons.forEach(button => {
                button.style.pointerEvents = 'none';
                button.style.opacity = '0.5';
            });

            // Set up the OK button click handler
            messageBox.querySelector('button').onclick = () => {
                messageBox.remove(); // Remove the message box
                isGamePausedForPopup = false; // Resume game when message box is closed

                // Re-enable and unfade menu buttons
                menuButtons.forEach(button => {
                    button.style.pointerEvents = 'auto';
                    button.style.opacity = '1';
                });
            };
        }

        // --- Game Logic ---
        const gameContainer = document.getElementById('game-container');
        const gameMainMenu = document.getElementById('game-main-menu'); 
        const menuPlayButton = document.getElementById('menu-play-button');
        const menuOptionsButton = document.getElementById('menu-options-button');
        const menuCreditsButton = document.getElementById('menu-credits-button');
        const menuExitButton = document.getElementById('menu-exit-button');

        const gameCanvas = document.getElementById("gameCanvas");
        const gameCtx = gameCanvas.getContext("2d");
        const gameDialogueBox = document.getElementById("dialogueBox");
        const gameDialogueText = document.getElementById("dialogueText");
        const gameOptions = document.getElementById("options");
        const bulletTutorialBox = document.getElementById("bulletTutorialBox");
        const tutorialContinueBtn = document.getElementById("tutorialContinueBtn");

        // Constants for Original Canvas Dimensions (for scaling calculations)
        const ORIGINAL_CANVAS_WIDTH = 1000;
        const ORIGINAL_CANVAS_HEIGHT = 700;
        let currentScale = 1; // Will be calculated dynamically

        // Game Area / Dodge Box dimensions and positions (Original values for scaling)
        const ORIGINAL_DODGE_BOX_WIDTH = 600;
        const ORIGINAL_DODGE_BOX_HEIGHT = 350;
        const ORIGINAL_DODGE_BOX_OFFSET_Y = 50; // Space from bottom
        const ORIGINAL_DODGE_BOX_Y = ORIGINAL_CANVAS_HEIGHT - ORIGINAL_DODGE_BOX_HEIGHT - ORIGINAL_DODGE_BOX_OFFSET_Y;
        
        let DODGE_BOX_WIDTH_SCALED;
        let DODGE_BOX_HEIGHT_SCALED;
        let DODGE_BOX_X_SCALED;
        let DODGE_BOX_Y_SCALED;

        // Fight Mini-game variables (Original values for scaling)
        const ORIGINAL_FIGHT_BAR_WIDTH = 400;
        const ORIGINAL_FIGHT_BAR_HEIGHT = 40; // Increased height
        const ORIGINAL_SWEET_SPOT_WIDTH = 80;
        const ORIGINAL_CRITICAL_SPOT_WIDTH = 20;

        // Dynamic spot size factors (min/max percentage of original size)
        const MIN_SWEET_SPOT_FACTOR = 0.3; // Sweet spot can shrink to 30% of original
        const MAX_SWEET_SPOT_FACTOR = 1.0; // Sweet spot is 100% at max HP
        const MIN_CRITICAL_SPOT_FACTOR = 0.1; // Critical spot can shrink to 10% of original
        const MAX_CRITICAL_SPOT_FACTOR = 1.0; // Critical spot is 100% at max HP

        // Dynamic marker speed factors (min/max multiplier of original speed)
        const MIN_HIT_MARKER_SPEED_FACTOR = 0.8; // Marker is 80% of original speed at max HP
        const MAX_HIT_MARKER_SPEED_FACTOR = 1.5; // Marker is 150% of original speed at low HP

        let FIGHT_BAR_WIDTH_SCALED;
        let FIGHT_BAR_HEIGHT_SCALED;
        let FIGHT_BAR_X_SCALED;
        let FIGHT_BAR_Y_SCALED;
        let SWEET_SPOT_WIDTH_SCALED;
        let CRITICAL_SPOT_WIDTH_SCALED;

        // New variables for random spot positions
        let currentSweetSpotOffset = 0;
        let currentCriticalSpotOffset = 0;

        let hitMarkerX;
        let hitMarkerDirection = 1; // 1 for right, -1 for left
        const HIT_MARKER_SPEED = 5; // Original speed, will be scaled dynamically

        // Player State
        const player = {
            x: 0, // Will be set by resizeCanvas
            y: 0, // Will be set by resizeCanvas
            originalSize: 16, // Original size for scaling
            size: 16, // Scaled size
            color: "red", // Current soul color
            determination: 0,
            maxDetermination: 50, // Reduced from 100 to 50
            isMoving: false, // Track if mouse is moving for Blue/Orange attacks
            lastMouseX: 0,
            lastMouseY: 0,
            movementTimeout: null, // For reliable isMoving detection
            speedMultiplier: 1, // For speed boost item
            invincible: false, // For invincibility ability
            invincibilityTimer: 0
        };

        // Global Game State Variables
        let gameState = "menu"; // Initial state
        let playerHP = 20;
        const playerMaxHP = 20;
        let invincibleFrames = 0;
        let currentEnemy = null;
        let enemiesSpared = 0;
        let enemiesDefeated = 0; // New: Track defeated enemies
        const totalEnemies = 4; // Updated total enemies
        let pacifistScore = 0; // For branching endings
        let screenShakeIntensity = 0;
        let screenShakeDuration = 0;
        let particles = []; // Array to hold particles
        let bullets = []; // Array to hold bullets
        let cosmicDustParticles = []; // For dynamic background
        let firstEncounter = true; // Flag to show bullet color hint only once
        let firstFightMinigame = true; // Flag to show attack bar hint only once
        let lastActedLabel = null; // Store the label of the last chosen ACT option
        let floatingTexts = []; // Array for hit/miss indicators
        let isGamePausedForPopup = false; // NEW: Flag to pause game logic during popups

        // NEW: Variables for multiple attacks per turn
        let currentAttackRound = 0; // Tracks current attack within an enemy's turn
        let totalAttacksThisTurn = 0; // Total attacks planned for the current enemy turn

        // Dialogue typing variables
        let currentDialogueText = "";
        let currentDialogueIndex = 0;
        let typingTimer = null;
        const TYPING_SPEED = 30; // Milliseconds per character
        let dialogueCallback = null; // Callback after typing finishes
        let skipTyping = false; // Flag to skip typing animation

        // Inventory System (Now stores objects with count for stacking)
        const inventory = []; // Initially empty, items will be added with addItemToInventory

        // Possible Item Drops (with their properties and drop chances)
        const possibleDrops = [
            { item: { name: "Bandage", type: "heal", value: 10, description: "A slightly used bandage. Smells faintly of friendship and... lint. Heals 10 HP!" }, chance: 0.3 }, // 30% chance
            { item: { name: "Doofy's Cookie", type: "heal", value: 5, description: "A slightly burnt cookie. Tastes like determination! Heals 5 HP." }, chance: 0.4 }, // 40% chance
            { item: { name: "Speedy Soda", type: "speed_boost", value: 1.5, duration: 300, description: "A fizzy drink that makes your soul zoom! Temporarily boosts movement speed." }, chance: 0.2 }, // 20% chance
            { item: { name: "Heartfelt Charm", type: "mercy_boost", value: 3, description: "A tiny charm that radiates kindness. Increases mercy gained from ACTs." }, chance: 0.15 }, // 15% chance
            { item: { name: "Bullet Eraser", type: "bullet_clear", description: "A mysterious device that makes bad bullets poof! Clears all bullets on screen." }, chance: 0.1 } // 10% chance
        ];

        // Enemy Data (Updated with Mercy, Check, Attack Combos, Moving, Flavor Text, HP)
        const enemies = [
            {
                name: "Floofy Pup",
                sprite: "üê∂",
                hp: 10, 
                maxHp: 10, 
                mercyThreshold: 6,
                currentMercy: 0,
                baseAttacksPerTurn: 4, // Increased from 1
                maxAttacksPerTurn: 6,  // Increased from 2
                dialogue: [
                    "A fluffy, over-enthusiastic pup bounces into view! It looks like it wants to play... a little too much. (Woof! Your soul turns RED, ready to dodge!)",
                    "The Floofy Pup wags its tail so hard it creates tiny whirlwinds! It's just trying to be friendly, honest!",
                    "It lets out a happy 'AWOOO!' and spins in circles. This pup has boundless energy, and it's all aimed at you!"
                ],
                actResponses: {
                    "Compliment üí¨": ["The pup blushes a deep, adorable red! üíï 'WOOF! You're the kindest human ever!' (It seems a little less bouncy now.)", "It barks happily and does a little wiggle dance! üê∂ 'AWOO! More compliments, please!' (You feel a tiny spark of friendship!)", "It spins in joy, then trips over its own paws! üéâ 'SQUEAK! You're too good to me!' (It's definitely warming up!)"],
                    "Pet gently üëã": ["It leans into your hand, melting like a fluffy marshmallow. So soft! 'Purrrrrr...' (Its barks seem softer, too.)", "A happy whimper escapes it, and it nudges your hand for more pets! 'So warm... you're the best!' (You feel a connection forming.)", "It licks your hand with a sloppy, affectionate lick! Aww! 'You're the best petter in the whole starfield!' (Its eyes sparkle with gratitude.)"],
                    "Offer treat ü¶¥": ["It happily munches the imaginary treat with gusto! 'NOM NOM NOM! Is this... a friendship treat?!' (It's practically purring!)", "Its eyes sparkle with gratitude, and it does a little treat dance! 'Thank you, friend! You're the best treat-giver!' (It's practically begging for more kindness!)", "It does a tiny, excited hop and sniffs your hand. 'Treat dance! Treat dance! You're so generous!' (You've definitely made a new friend!)"]
                },
                miniAttackDialogue: [
                    "The pup hesitates, then sends a small, apologetic bark! 'Oops! Did I do that?'",
                    "It's trying to be gentle, but its barks are getting weaker. 'Just... a little... woof...' ",
                    "A soft, sleepy woof... it's barely a threat. 'Are we... still playing?'",
                    "It looks away, sending a very weak, almost shy bark. 'I didn't mean it... much.'"
                ],
                // ACT mini-attacks: More challenging and longer
                miniAttackPatterns: [
                    { type: "randomBullets", bulletType: "red", bulletSprite: "ü¶¥", baseSpeed: 3, baseSpawnFrequency: 8, baseDuration: 200 }, 
                    { type: "targetedBullets", bulletType: "red", bulletSprite: "üçñ", baseSpeed: 4, baseSpawnFrequency: 12, baseDuration: 180 }
                ],
                checkDescription: "FLOOFY PUP - A very good boy/girl. Loves head pats and compliments. Seems a bit clumsy but means well. HP: ?? ATK: ?? DEF: ?? (It's got a heart of gold, if a bit energetic!)",
                defeatedDialogue: "The Floofy Pup whimpers softly and curls up into a tiny, defeated ball. It looks a little sad, but also relieved. 'Woof... good game, friend. I'll nap now.'", 
                attackPatterns: [
                    // Phase 1: Playful Barks (Red - Standard Dodge)
                    { type: "randomBullets", bulletType: "red", bulletSprite: "üê∂", bulletSpeed: 4, spawnFrequency: 5, duration: 120, flavor: "The pup sends a flurry of happy woofs! Dodge its playful barks!" },
                    { type: "expandingCircle", bulletType: "red", bulletSprite: "üêæ", bulletSpeed: 3, spawnFrequency: 30, duration: 150, flavor: "It barks, sending out a shockwave of paw prints! Watch out!" },
                    { type: "targetedBullets", bulletType: "red", bulletSprite: "üçñ", bulletSpeed: 5, spawnFrequency: 10, duration: 100, flavor: "A focused bark comes your way! It's surprisingly precise!" },
                    
                    // Phase 2: Zoomies! (Red - More intense)
                    { type: "randomBullets", bulletType: "red", bulletSprite: "ü¶¥", bulletSpeed: 6, spawnFrequency: 3, duration: 180, flavor: "Its zoomies are surprisingly chaotic! Bones everywhere!" },
                    { type: "expandingCircle", bulletType: "red", bulletSprite: "üêæ", bulletSpeed: 4, spawnFrequency: 20, duration: 200, flavor: "A rapid, expanding bark-wave! Don't get caught!" },
                    { type: "lineBullets", bulletType: "red", bulletSprite: "ü¶¥", bulletSpeed: 5, spawnFrequency: 25, duration: 150, flavor: "It runs in lines, sending out barks! A furry obstacle course!" },
                    
                    // Phase 3: Overjoyed Barrage (Red - Highest intensity)
                    { type: "randomBullets", bulletType: "red", bulletSprite: "ü¶¥", bulletSpeed: 7, spawnFrequency: 2, duration: 200, flavor: "An overwhelming wave of happy barks! It's just so excited!" },
                    { type: "spiralBullets", bulletType: "red", bulletSprite: "üêæ", bulletSpeed: 5, spawnFrequency: 5, duration: 250, flavor: "It spins in joy, creating a bark spiral! A dizzying display of affection!" }
                ],
                canMove: false,
                originalX: ORIGINAL_CANVAS_WIDTH / 2,
                originalY: ORIGINAL_DODGE_BOX_Y - 100
            },
            {
                name: "Dizzy Duckling",
                sprite: "ü¶Ü",
                hp: 12, 
                maxHp: 12, 
                mercyThreshold: 8,
                currentMercy: 0,
                baseAttacksPerTurn: 5, // Increased from 1
                maxAttacksPerTurn: 7, // Increased from 3
                dialogue: [
                    "A wobbly, adorable duckling quacks into view! It seems a bit disoriented, like it just spun around too many times. (Quack! Your soul turns BLUE, so stay still!)",
                    "It looks a bit lost, trying to find its way with tiny, confused steps. Its quacks are full of innocent bewilderment.",
                    "It's trying to balance on one leg, then the other, wobbling precariously. This duckling is a master of unintentional chaos!"
                ],
                actResponses: {
                    "Compliment üí¨": ["It honks adorably and puffs out its chest! ü¶Ü 'Quack-tastic compliment! You're so kind to a little duck like me!'", "It flaps its tiny wings excitedly! ü™Ω 'You make me feel like I can fly! Maybe I'll try that later!'", "It winks back with one eye! üòâ 'You're pretty cool for a human. Not as wobbly as some!'"],
                    "Help balance ü§∏": ["It steadies itself with your help, letting out a grateful 'Phew, almost fell!' (It looks much more confident now!)", "It gives a grateful quack and leans against your soul! 'Thanks for the assist! You're a true friend!' (You feel a tiny feather of trust.)", "You've earned its trust! It tries to walk a straight line, mostly succeeding. 'You're a true friend to ducks... and wobbly things!'"]
                },
                miniAttackDialogue: [
                    "The duckling wobbles, sending a tiny, confused splash! 'Oopsie!'",
                    "It tries to aim, but its quacks are getting weaker and more off-target. 'Where did it go?'",
                    "A very confused quack... it's barely a threat. 'Is this... a game?'",
                    "It just stares, then a single, slow, apologetic drop falls. 'Sorry!'"
                ],
                // ACT mini-attacks: More challenging and longer
                miniAttackPatterns: [
                    { type: "waveBullets", bulletType: "blue", bulletSprite: "üíß", baseSpeed: 3.5, baseSpawnFrequency: 15, baseDuration: 220 },
                    { type: "randomBullets", bulletType: "blue", bulletSprite: "üí¶", baseSpeed: 2.5, baseSpawnFrequency: 10, baseDuration: 200 }
                ],
                checkDescription: "DIZZY DUCKLING - A confused but charming little feathered friend. Easily distracted by shiny objects or good jokes. HP: ?? ATK: ?? DEF: ?? (It probably thinks you're a giant, friendly pond.)",
                defeatedDialogue: "The Dizzy Duckling spins to a halt, looking dizzy but unharmed. 'Quack... you got me! I need a nap. Maybe a long one.'", 
                attackPatterns: [
                    // Phase 1: Wobbly Quacks (Blue - Stop to Dodge) - Slightly faster
                    { type: "waveBullets", bulletType: "blue", bulletSprite: "üíß", bulletSpeed: 5, spawnFrequency: 12, duration: 130, flavor: "The duckling wobbles, sending out BLUE waves! Hold still!" },
                    { type: "targetedBullets", bulletType: "blue", bulletSprite: "üí¶", bulletSpeed: 6, spawnFrequency: 10, duration: 110, flavor: "It tries to pinpoint you with BLUE quacks! Don't move a muscle!" },
                    { type: "randomBullets", bulletType: "blue", bulletSprite: "üíß", bulletSpeed: 4, spawnFrequency: 6, duration: 160, flavor: "Confused BLUE pecks everywhere! Stay frosty, or rather, stay still!" },

                    // Phase 2: Confused Flurry (Blue/Red Mix - More dynamic and faster)
                    { type: "spiralBullets", bulletType: "blue", bulletSprite: "üåÄ", bulletSpeed: 5, spawnFrequency: 7, duration: 190, flavor: "A dizzying BLUE spiral! It's trying its best, honest!" },
                    { type: "lineBullets", bulletType: "red", bulletSprite: "üåä", bulletSpeed: 7, spawnFrequency: 18, duration: 160, flavor: "Sudden red lines appear! Quick, move out of the way!" },
                    { type: "expandingCircle", bulletType: "blue", bulletSprite: "üíß", bulletSpeed: 4, spawnFrequency: 22, duration: 180, flavor: "A wobbly BLUE shockwave! Don't let it splash you!" },

                    // Phase 3: Panic Quacks (Blue/Red - High intensity, very fast)
                    { type: "waveBullets", bulletType: "blue", bulletSprite: "üíß", bulletSpeed: 7, spawnFrequency: 8, duration: 210, flavor: "Fast, relentless BLUE waves! This duckling is in a panic!" },
                    { type: "targetedBullets", bulletType: "red", bulletSprite: "üí¶", bulletSpeed: 8, spawnFrequency: 6, duration: 160, flavor: "Rapid red pecks! It's getting serious... for a duckling!" },
                    { type: "randomBullets", bulletType: "blue", bulletSprite: "üíß", bulletSpeed: 6, spawnFrequency: 3, duration: 230, flavor: "A chaotic storm of BLUE! It's lost its marbles... or quackers!" }
                ],
                canMove: true,
                originalX: ORIGINAL_CANVAS_WIDTH / 2,
                originalY: ORIGINAL_DODGE_BOX_Y - 100
            },
            {
                name: "Snoozy Sloth",
                sprite: "ü¶•",
                hp: 15, 
                maxHp: 15, 
                mercyThreshold: 7,
                currentMercy: 0,
                baseAttacksPerTurn: 6, // Increased from 2
                maxAttacksPerTurn: 8, // Increased from 4
                dialogue: [
                    "A very, very slow sloth yawns a cavernous yawn. It looks like it just woke up from a century-long nap. (Your soul is RED, but its attacks are like a slow-motion dream!)",
                    "It's moving at a glacial pace, as if time itself is slowing down around it. Don't let its slowness fool you; its attacks can still sting, eventually!",
                    "Another yawn, so wide you could drive a spaceship through it. It seems more interested in napping than fighting. Maybe you can convince it to just... go back to sleep."
                ],
                actResponses: {
                    "Tell a bedtime story üò¥": ["The sloth's eyes droop, heavy with sleep. 'Zzz... a good story. Tell me another... slowly.' (Mercy increases! It's almost out cold!)", "It snuggles into an imaginary blanket, a contented sigh escaping its lips. 'So cozy... like a cloud made of leaves.' (You're practically a lullaby maestro!)", "It's almost asleep, swaying gently! 'More... slow tales... of fluffy clouds and soft moss...' (Success! It's practically dreaming!)"],
                    "Offer a leaf üçÉ": ["It slowly, *very* slowly, takes the leaf and munches with profound concentration. 'Mmm... fresh. A true delicacy.' (It seems genuinely pleased!)", "A contented sigh escapes it, like a gentle breeze. 'Delicious. You understand the finer things in life... like leaves.' (You've found the way to its sleepy heart!)", "It looks at you with sleepy gratitude, then slowly blinks. 'You understand. The sacred leaf... thank you.' (A bond of leafy friendship forms!)"],
                    "Sing a lullaby üé∂": ["The sloth starts to sway gently, its eyelids fluttering. 'Soothing... so very soothing. My dreams are calling.' (It's almost completely relaxed!)", "It closes its eyes, a tiny, peaceful smile on its face. 'Sweet dreams... you have a calming voice, like a gentle forest breeze.' (You're a natural at this!)", "It's completely relaxed, practically melting into the air. 'You are... a master of calm. I shall... rest now.' (It's definitely feeling the good vibes!)"]
                },
                miniAttackDialogue: [
                    "The sloth yawns again, and a few slow, floaty Z's drift your way. 'Just... a little... stretch...'",
                    "It's too sleepy to aim properly... or move fast. Its attacks are more like gentle nudges. 'Are we... still doing this?'",
                    "Zzz... just a tiny, slow puff of sleepiness. It looks like it's fighting to stay awake. 'So... tired...' ",
                    "It's barely awake enough to acknowledge you, sending out the slowest, most apologetic attack ever. '...zzzz...'"
                ],
                // ACT mini-attacks: More challenging and longer
                miniAttackPatterns: [
                    { type: "randomBullets", bulletType: "red", bulletSprite: "üí§", baseSpeed: 2.5, baseSpawnFrequency: 20, baseDuration: 250 }, 
                    { type: "targetedBullets", bulletType: "red", bulletSprite: "üêå", baseSpeed: 3, baseSpawnFrequency: 25, baseDuration: 230 }
                ],
                checkDescription: "SNOOZY SLOTH - A magnificent creature of extreme leisure. Its favorite hobbies include napping, slow-motion blinking, and contemplating the existential dread of Mondays. HP: ?? ATK: ?? DEF: ?? (Don't wake it up too fast, it gets grumpy.)",
                defeatedDialogue: "The Snoozy Sloth collapses into a heap, instantly falling asleep with a loud snore. 'Too... much... effort... Zzzz.' (You've successfully helped it achieve peak relaxation!)", 
                attackPatterns: [
                    // Phase 1: Slow Wake-Up (Red - Slow but steady, but more bullets)
                    { type: "targetedBullets", bulletType: "red", bulletSprite: "üåø", bulletSpeed: 3, spawnFrequency: 25, duration: 160, flavor: "Slow, deliberate leaf darts drift your way. Don't get stuck!" },
                    { type: "randomBullets", bulletType: "red", bulletSprite: "üí§", bulletSpeed: 2.5, spawnFrequency: 15, duration: 190, flavor: "Sleepy, drifting z's fill the air. Try not to yawn!" },
                    { type: "expandingCircle", bulletType: "red", bulletSprite: "üêå", bulletSpeed: 3.5, spawnFrequency: 35, duration: 170, flavor: "A slow, expanding yawn-wave! It's surprisingly wide!" },

                    // Phase 2: Gentle Stretch (Blue/Red mix - faster, more complex)
                    { type: "waveBullets", bulletType: "blue", bulletSprite: "‚òÅÔ∏è", bulletSpeed: 4, spawnFrequency: 20, duration: 180, flavor: "Wobbly cloud-like attacks float by. Remember to STOP moving for blue!" },
                    { type: "lineBullets", bulletType: "red", bulletSprite: "üçÉ", bulletSpeed: 4.5, spawnFrequency: 25, duration: 150, flavor: "Straight lines of leaves! They're sharper than they look!" },
                    { type: "spiralBullets", bulletType: "blue", bulletSprite: "üåÄ", bulletSpeed: 3.5, spawnFrequency: 12, duration: 210, flavor: "A slow, swirling dream-cloud! Try not to get caught in its slumber!" },

                    // Phase 3: Almost Asleep (Orange/Red - mix of slow and sudden, higher density)
                    { type: "targetedBullets", bulletType: "orange", bulletSprite: "üò¥", bulletSpeed: 5, spawnFrequency: 8, duration: 140, flavor: "Sudden sleepy blinks! Keep moving to avoid these drowsy attacks!" },
                    { type: "randomBullets", bulletType: "orange", bulletSprite: "üí§", bulletSpeed: 4, spawnFrequency: 6, duration: 190, flavor: "Drifting sleep particles! They're trying to put you to sleep!" },
                    { type: "expandingCircle", bulletType: "red", bulletSprite: "üêå", bulletSpeed: 4.5, spawnFrequency: 20, duration: 200, flavor: "A final, big yawn-explosion! This sloth is ready for bed!" }
                ],
                canMove: true,
                originalX: ORIGINAL_CANVAS_WIDTH / 2,
                originalY: ORIGINAL_DODGE_BOX_Y - 100
            },
            {
                name: "Grumpy Golem", // BOSS ENEMY
                sprite: "üóø",
                hp: 30, 
                maxHp: 30, 
                mercyThreshold: 12, 
                currentMercy: 0,
                baseAttacksPerTurn: 7, // Increased from 3
                maxAttacksPerTurn: 10, // Increased from 5
                dialogue: [
                    "A massive, stony golem grumbles into existence, looking like it just lost its favorite rock. It seems... utterly unimpressed by your presence. (Uh oh! Your soul turns ORANGE!)",
                    "It sighs, and dust motes become sharp, angry projectiles. This golem is definitely having a bad day, and it's taking it out on the starfield... and you!",
                    "It lets out a low, rumbling growl. 'Hmph. Another... obstacle.' Its stony glare is unyielding, radiating pure grumpiness. You're in for a tough one!",
                    "THE GOLEM'S RAGE INTENSIFIES! ITS STONY GLARE IS UNYIELDING! (It's getting serious! This is the big one!)" 
                ],
                actResponses: {
                    "Compliment üí¨": ["It grumbles, but a tiny, almost imperceptible smile appears on its rocky face. 'Hmph. Not bad for a squishy human.' (A small crack appears on its stony heart!)", "A faint, warm glow emanates from its eyes, like embers in a cave. '...Thank you. Your words are... less annoying than most.' (It seems slightly less grumpy!)", "It actually nods slightly, sending a few pebbles tumbling. 'Perhaps not all humans are... loud and bothersome.' (You've found a tiny chink in its stony armor!)"],
                    "Tell a pun üé§": ["Why don't scientists trust atoms? Because they make up everything! (The golem seems to crack a little smile, a deep rumble of amusement escaping it. 'Heh. Solid joke. For a human.')", "What do you call a sad strawberry? A blueberry! (It lets out a low, rumbling chuckle, shaking the ground slightly. 'You're... berry funny. For a fleeting existence.')"],
                    "Offer a flower üå∏": ["It carefully, almost delicately, takes the flower. A small, loose rock falls from its face. 'A delicate gesture. Unexpected.' (The flower seems to soften its aura!)", "The flower seems to brighten its stony demeanor, and it sniffs it cautiously. 'It smells... less like dust. And more like... hope?' (It's actually contemplating the flower!)", "It places the flower on its head, looking surprisingly less grumpy. '...This is acceptable. A small piece of beauty in this... chaotic existence.' (You've made a grumpy friend!)"]
                },
                miniAttackDialogue: [
                    "The golem grumbles, sending a small, slow pebble your way. 'Just... a warm-up.'",
                    "It sighs, and a few dust motes drift lazily. It's barely putting effort into this. 'Too much... effort.'",
                    "A reluctant shrug... its attacks are half-hearted, like it's just going through the motions. 'Are we done yet?'",
                    "It just stares, barely bothering to throw anything. A single, tiny, sad pebble rolls towards you. '...' "
                ],
                // ACT mini-attacks: Most challenging and longest
                miniAttackPatterns: [
                    { type: "targetedBullets", bulletType: "orange", bulletSprite: "ü™®", baseSpeed: 4, baseSpawnFrequency: 18, baseDuration: 280 }, 
                    { type: "expandingCircle", bulletType: "orange", bulletSprite: "üå´Ô∏è", baseSpeed: 3, baseSpawnFrequency: 25, baseDuration: 260 }
                ],
                checkDescription: "GRUMPY GOLEM - A colossal creature of pure rock and bad moods. Its hobbies include brooding, staring intensely, and judging everyone. HP: ?? ATK: ?? DEF: ?? (Rumor has it, it secretly loves glitter.)",
                defeatedDialogue: "The Grumpy Golem shudders, cracks appearing across its stony body. It crumbles into a pile of harmless, slightly sparkly pebbles. '...Finally... peace. And maybe... a nap.'", 
                attackPatterns: [
                    // BOSS PHASE 1: Stony Grumbles (Orange - Move to Dodge, increasing intensity)
                    { type: "spiralBullets", bulletType: "orange", bulletSprite: "ü™®", bulletSpeed: 5, spawnFrequency: 5, duration: 160, flavor: "The golem unleashes an ORANGE stony spiral! Keep moving!" },
                    { type: "lineBullets", bulletType: "orange", bulletSprite: "üß±", bulletSpeed: 6, spawnFrequency: 18, duration: 130, flavor: "It sends ORANGE rock lines across the box! Don't get walled in!" },
                    { type: "targetedBullets", bulletType: "orange", bulletSprite: "ü™®", bulletSpeed: 7, spawnFrequency: 7, duration: 110, flavor: "Precise ORANGE pebbles! They're coming for you!" },
                    { type: "expandingCircle", bulletType: "orange", bulletSprite: "üí•", bulletSpeed: 5.5, spawnFrequency: 22, duration: 190, flavor: "An ORANGE shockwave from its stomp! Move it, move it!" },

                    // BOSS PHASE 2: Boulder Barrage (Orange/Red Mix - More intense, faster, higher density)
                    { type: "randomBullets", bulletType: "red", bulletSprite: "‚òÑÔ∏è", bulletSpeed: 7, spawnFrequency: 2, duration: 160, flavor: "A shower of red cosmic debris! It's raining rocks!" },
                    { type: "lineBullets", bulletType: "orange", bulletSprite: "üß±", bulletSpeed: 8, spawnFrequency: 12, duration: 180, flavor: "Fast, crossing ORANGE lines! Dodge the grid!" },
                    { type: "spiralBullets", bulletType: "red", bulletSprite: "üå™Ô∏è", bulletSpeed: 6.5, spawnFrequency: 3, duration: 210, flavor: "A dizzying red dust devil! Don't get sucked in!" },
                    { type: "targetedBullets", bulletType: "orange", bulletSprite: "ü™®", bulletSpeed: 8.5, spawnFrequency: 5, duration: 140, flavor: "Relentless ORANGE rock throws! No time to rest!" },

                    // BOSS PHASE 3: Earth Shatter (Orange/Red - Highest intensity, rapid combos, max density)
                    { type: "expandingCircle", bulletType: "red", bulletSprite: "üåã", bulletSpeed: 6, spawnFrequency: 18, duration: 230, flavor: "Massive red ground shakes! Feel the rumble!" },
                    { type: "waveBullets", bulletType: "orange", bulletSprite: "‚õ∞Ô∏è", bulletSpeed: 7.5, spawnFrequency: 8, duration: 190, flavor: "Crushing ORANGE earth waves! Ride the storm!" },
                    { type: "randomBullets", bulletType: "red", bulletSprite: "‚òÑÔ∏è", bulletSpeed: 9, spawnFrequency: 1, duration: 210, flavor: "A chaotic storm of red meteors! This is getting wild!" },
                    { type: "spiralBullets", bulletType: "orange", bulletSprite: "üåÄ", bulletSpeed: 8, spawnFrequency: 2, duration: 260, flavor: "Unstoppable ORANGE vortex! Don't get dizzy!" },
                    { type: "lineBullets", bulletType: "red", bulletSprite: "‚ö°", bulletSpeed: 9.5, spawnFrequency: 8, duration: 160, flavor: "Lightning-fast red fissures! This is the grand finale!" }
                ],
                canMove: true,
                originalX: ORIGINAL_CANVAS_WIDTH / 2,
                originalY: ORIGINAL_DODGE_BOX_Y - 100
            }
        ];

        let currentAttackIndex = 0; // Tracks which attack pattern in the combo is active
        let currentEnemyAttackTimer = 0;
        let currentAttackDuration = 0;
        let currentAttackFlavorText = "";
        let glitchOpacity = 0; // For screen glitch effect

        // --- Mouse Control for Player ---
        gameCanvas.addEventListener('mousemove', (e) => {
            if (gameState === "enemy_attack_phase" || gameState === "enemy_mini_attack_phase" || gameState === "bullet_tutorial") {
                const rect = gameCanvas.getBoundingClientRect();
                // Get mouse coordinates relative to the canvas
                const mouseX = (e.clientX - rect.left) * (gameCanvas.width / rect.width);
                const mouseY = (e.clientY - rect.top) * (gameCanvas.height / rect.height);

                // Set player as moving
                player.isMoving = true;
                // Clear any existing timeout
                if (player.movementTimeout) {
                    clearTimeout(player.movementTimeout);
                }
                // Set a new timeout to mark player as not moving if no further mousemove events occur
                player.movementTimeout = setTimeout(() => {
                    player.isMoving = false;
                }, 150); // 150ms of no movement to be considered stationary

                // Clamp player position to the scaled dodge box
                player.x = Math.max(DODGE_BOX_X_SCALED, Math.min(DODGE_BOX_X_SCALED + DODGE_BOX_WIDTH_SCALED - player.size, mouseX - player.size / 2));
                player.y = Math.max(DODGE_BOX_Y_SCALED, Math.min(DODGE_BOX_Y_SCALED + DODGE_BOX_HEIGHT_SCALED - player.size, mouseY - player.size / 2));

                player.lastMouseX = mouseX; // Update last known mouse position
                player.lastMouseY = mouseY;
            }
        });

        // --- Game Utility Functions ---

        /**
         * Draws a rectangle. For pixel art, we avoid rounding.
         * @param {CanvasRenderingContext2D} ctx - The rendering context.
         * @param {number} x - The x-coordinate of the upper-left corner of the rectangle.
         * @param {number} y - The y-coordinate of the upper-left corner of the rectangle.
         * @param {number} width - The width of the rectangle.
         * @param {number} height - The height of the rectangle.
         */
        function drawRect(ctx, x, y, width, height) {
            ctx.beginPath();
            ctx.rect(x, y, width, height);
            ctx.closePath();
            // No fill or stroke here, just path creation. Caller will fill/stroke.
        }

        /**
         * Draws the player's heart soul.
         * @param {number} x - X coordinate.
         * @param {number} y - Y coordinate.
         * @param {number} size - Size of the heart.
         * @param {string} color - Color of the heart.
         */
        function drawHeart(x, y, size, color) {
            gameCtx.fillStyle = color;
            gameCtx.beginPath();
            const topCurveHeight = size * 0.3;
            gameCtx.moveTo(x, y + topCurveHeight);
            gameCtx.bezierCurveTo(x, y, x - size, y, x - size, y + topCurveHeight);
            gameCtx.bezierCurveTo(x - size, y + size, x, y + size * 1.8, x, y + size * 2);
            gameCtx.bezierCurveTo(x, y + size * 1.8, x + size, y + size, x + size, y + topCurveHeight);
            gameCtx.bezierCurveTo(x + size, y, x, y, x, y + topCurveHeight);
            gameCtx.closePath();
            gameCtx.fill();
        }

        /**
         * Spawns particles for visual effects.
         * @param {number} x - X coordinate.
         * @param {number} y - Y coordinate.
         * @param {string} emoji - Emoji to use for particles.
         * @param {string} color - Color for the particle (if not emoji)
         */
        function spawnParticles(x, y, emoji = "‚ú®", color = "white") {
            for (let i = 0; i < 10; i++) {
                particles.push({
                    x,
                    y,
                    vx: (Math.random() - 0.5) * 3 * currentScale, // Scale particle velocity
                    vy: (Math.random() - 0.5) * 3 * currentScale,
                    life: 60,
                    emoji,
                    color
                });
            }
        }

        /**
         * Updates particle positions and removes expired ones.
         */
        function updateParticles() {
            particles = particles.filter(p => p.life > 0);
            particles.forEach(p => {
                p.x += p.vx;
                p.y += p.vy;
                p.life--;
            });
        }

        /**
         * Draws all active particles.
         */
        function drawParticles() {
            particles.forEach(p => {
                gameCtx.font = `${24 * currentScale}px 'Press Start 2P'`; /* Scale particle font, slightly larger */
                gameCtx.fillStyle = p.color;
                gameCtx.fillText(p.emoji, p.x, p.y);
            });
        }

        /**
         * Spawns a single bullet.
         * @param {number} x - X coordinate.
         * @param {number} y - Y coordinate.
         * @param {number} vx - Velocity X.
         * @param {number} vy - Velocity Y.
         * @param {number} size - Size of the bullet.
         * @param {string} type - Type of bullet ("red", "blue", "orange").
         * @param {string} sprite - Emoji sprite for the bullet.
         */
        function spawnBullet(x, y, vx, vy, size = 14, type = "red", sprite = "‚óÜ") { /* Slightly larger default bullet size */
            let color;
            if (type === "blue") {
                color = "blue";
            } else if (type === "orange") {
                color = "orange";
            } else {
                color = "gold"; // Default for "red" (normal)
            }
            bullets.push({ x, y, vx, vy, size: size * currentScale, color, type, sprite }); // Scale bullet size
        }

        /**
         * Updates bullet positions and removes out-of-bounds bullets.
         */
        function updateBullets() {
            bullets = bullets.filter(b => 
                // Keep bullets within canvas bounds (with a small buffer)
                b.x > -b.size && b.x < gameCanvas.width + b.size &&
                b.y > -b.size && b.y < gameCanvas.height + b.size
            );
            bullets.forEach(b => {
                b.x += b.vx;
                b.y += b.vy;
            });
        }

        /**
         * Draws all active bullets.
         */
        function drawBullets() {
            bullets.forEach(b => {
                // Draw emoji sprite for the bullet
                gameCtx.font = `${b.size * 1.5}px 'Press Start 2P'`; /* Keep pixel font for bullets */
                gameCtx.textAlign = "center";
                gameCtx.textBaseline = "middle";
                gameCtx.fillText(b.sprite, b.x + b.size / 2, b.y + b.size / 2);
            });
            gameCtx.textAlign = "left"; // Reset
            gameCtx.textBaseline = "alphabetic"; // Reset
        }

        /**
         * Checks for collisions between player and bullets, handling blue/orange types.
         */
        function checkCollisions() {
            if (player.invincible) {
                return; // Player is invincible, no damage taken
            }
            if (invincibleFrames > 0) {
                invincibleFrames--;
                return; // Player is invincible, no damage taken
            }

            let hitOccurredInThisFrame = false; // New flag to track if a hit (leading to damage) occurred this frame

            bullets.forEach(b => {
                // Simple AABB collision detection
                if (player.x < b.x + b.size &&
                    player.x + player.size > b.x &&
                    player.y < b.y + b.size &&
                    player.y + player.size > b.y) {
                    
                    let damage = 1; // Default damage
                    let hit = true;

                    if (b.type === "blue") {
                        if (!player.isMoving) {
                            damage = 0; // No damage if blue and stationary
                            hit = false;
                        }
                    } else if (b.type === "orange") {
                        if (player.isMoving) {
                            damage = 0; // No damage if orange and moving
                            hit = false;
                        }
                    }

                    if (hit) {
                        // Only apply damage and effects if a hit hasn't already occurred this frame
                        if (!hitOccurredInThisFrame) {
                            playerHP = Math.max(0, playerHP - damage);
                            invincibleFrames = 60; // 1 second invincibility (60 frames at 60fps)
                            flashBorder();
                            spawnParticles(player.x, player.y, "üí•");
                            spawnFloatingText(player.x + player.size / 2, player.y - 10, "HIT!", "red");
                            screenShake(5, 10); // Small screen shake on hit
                            playerHitSound.triggerAttackRelease("C3", "8n"); // Play hit sound only once per frame
                            if (playerHP <= 0) {
                                setGameState("game_over");
                                bullets = [];
                                particles = [];
                                setTimeout(() => {
                                    showGameOverScreen();
                                }, 200);
                                // No return here, let the loop finish, but the game state change will stop further processing
                            }
                            hitOccurredInThisFrame = true; // Mark that a hit leading to damage occurred this frame
                        }
                        // If hitOccurredInThisFrame is true, subsequent bullets hitting in the same frame won't cause damage or play sound
                    } else {
                        spawnParticles(b.x, b.y, "‚ú®"); // Still show sparkle for dodged bullets
                    }
                }
            });
        }

        /**
         * Spawns a floating text message.
         * @param {number} x - X coordinate.
         * @param {number} y - Y coordinate.
         * @param {string} text - The text to display.
         * @param {string} color - CSS color for the text.
         */
        function spawnFloatingText(x, y, text, color = "white") {
            const textElement = document.createElement('div');
            textElement.className = 'floating-text';
            textElement.textContent = text;
            textElement.style.left = `${x}px`;
            textElement.style.top = `${y}px`;
            textElement.style.color = color;
            gameContainer.appendChild(textElement);

            // Remove after animation
            textElement.addEventListener('animationend', () => {
                textElement.remove();
            });
        }

        /**
         * Updates floating text positions and removes expired ones.
         */
        function updateFloatingTexts() {
            floatingTexts = floatingTexts.filter(t => t.life > 0);
            floatingTexts.forEach(t => {
                t.y += t.vy;
                t.life--;
                t.opacity = t.life / 60; // Fade out over time
            });
        }

        /**
         * Draws all active floating texts.
         */
        function drawFloatingTexts() {
            floatingTexts.forEach(t => {
                gameCtx.save();
                gameCtx.globalAlpha = t.opacity;
                gameCtx.fillStyle = t.color;
                gameCtx.font = `${t.size * currentScale}px 'Press Start 2P'`;
                gameCtx.textAlign = "center";
                gameCtx.fillText(t.text, t.x, t.y);
                gameCtx.restore();
            });
        }

        /**
         * Applies a screen shake effect.
         * @param {number} intensity - How much the screen shakes.
         * @param {number} duration - How long the shake lasts (frames).
         */
        function screenShake(intensity, duration) {
            screenShakeIntensity = intensity * currentScale; // Scale shake intensity
            screenShakeDuration = duration;
        }

        /**
         * Draws a glitch effect on the canvas.
         */
        function drawGlitch() {
            if (glitchOpacity > 0) {
                gameCtx.fillStyle = `rgba(255,255,255,${glitchOpacity})`;
                gameCtx.fillRect(0, 0, gameCanvas.width, gameCanvas.height);
                glitchOpacity -= 0.02; // Reduce opacity over time
            }
        }

        /**
         * Triggers a glitch effect.
         * @param {Function} callback - Function to call after the glitch.
         */
        function triggerGlitch(callback) {
            glitchOpacity = 0.7; // Start with high opacity
            setTimeout(callback, 400); // Call callback after a short delay
        }

        /**
         * Flashes the canvas border on damage.
         */
        function flashBorder() {
            gameCanvas.style.boxShadow = "0 0 20px red";
            setTimeout(() => gameCanvas.style.boxShadow = "5px 5px 0px rgba(0, 0, 0, 0.7)", 150); // Restore original shadow
        }

        /**
         * Displays dialogue text character by character.
         * @param {string} text - The text to display.
         * @param {Function} callback - Function to call after text is displayed.
         */
        function typeText(text, callback) {
            currentDialogueText = text;
            currentDialogueIndex = 0;
            gameDialogueText.textContent = ""; // Clear immediately
            gameDialogueText.style.borderRight = '3px solid #e0e0e0'; // Blinking cursor
            dialogueCallback = callback;
            skipTyping = false; // Reset skip flag

            if (typingTimer) {
                clearTimeout(typingTimer);
            }

            function typeCharacter() {
                if (skipTyping) {
                    gameDialogueText.textContent = currentDialogueText;
                    gameDialogueText.style.borderRight = 'none'; // Hide cursor
                    if (dialogueCallback) {
                        dialogueCallback();
                    }
                    return;
                }

                if (currentDialogueIndex < currentDialogueText.length) {
                    gameDialogueText.textContent += currentDialogueText.charAt(currentDialogueIndex);
                    // Schedule sound with a small, increasing offset to avoid "strictly greater" error
                    // Use Tone.context.currentTime for more reliable scheduling
                    typingSound.triggerAttackRelease("C4", "32n", Tone.context.currentTime + (currentDialogueIndex * 0.005)); 
                    currentDialogueIndex++;
                    typingTimer = setTimeout(typeCharacter, TYPING_SPEED);
                } else {
                    gameDialogueText.style.borderRight = 'none'; // Hide cursor
                    if (dialogueCallback) {
                        dialogueCallback();
                    }
                }
            }
            typeCharacter();
        }

        // Event listener to skip typing
        gameDialogueBox.addEventListener('click', () => {
            if (gameState.includes("dialogue") || gameState.includes("menu") || isGamePausedForPopup) { // Allow skipping even if technically paused
                skipTyping = true;
            }
        });


        /**
         * Displays dialogue box with text and optional buttons.
         * @param {string} text - Dialogue text.
         * @param {Array<Object>} buttons - Array of button objects {label, action}.
         */
        function showDialogue(text, buttons = []) {
            // Pause the game when dialogue appears
            isGamePausedForPopup = true;

            if (!gameOptions) { 
                console.error("Error: gameOptions element not found!"); 
                return; 
            }
            gameDialogueBox.style.display = "block";
            gameOptions.innerHTML = ""; // Clear existing options immediately before adding new ones
            gameDialogueText.textContent = ""; // Clear existing text content
            typeText(text, () => { // Use typeText to display the text
                buttons.forEach(({ label, action }) => {
                    const btn = document.createElement("button");
                    btn.className = "optionButton game-button"; /* Apply game-button styles */
                    btn.innerText = label;
                    btn.onclick = () => {
                        buttonClickSound.triggerAttackRelease("C5", "16n"); // Play button click sound
                        isGamePausedForPopup = false; // Resume game when dialogue button is clicked
                        action();
                    };
                    gameOptions.appendChild(btn);
                });
            });
        }

        /**
         * Returns a random element from an array.
         * @param {Array} arr - The array.
         * @returns {*} A random element.
         */
        function randomFrom(arr) {
            return arr[Math.floor(Math.random() * arr.length)];
        }

        /**
         * Adds an item to the inventory, handling stacking.
         * @param {Object} itemToAdd - The item object to add.
         */
        function addItemToInventory(itemToAdd) {
            const existingItem = inventory.find(item => item.name === itemToAdd.name);
            if (existingItem) {
                existingItem.count = (existingItem.count || 1) + 1; // Increment count, default to 1 if not set
                showCustomMessage(`You found another ${itemToAdd.name}! Now you have ${existingItem.count}! ‚ú®`);
            } else {
                inventory.push({ ...itemToAdd, count: 1 }); // Add new item with count 1
                showCustomMessage(`You found a ${itemToAdd.name}! What a treasure! üåü`);
            }
            itemPickupSound.triggerAttackRelease("G6", "16n"); // Play item pickup sound
            spawnParticles(player.x, player.y, "‚ú®", "gold");
        }

        /**
         * Draws the HP bar, HP text, Mercy bar, and Determination bar.
         */
        function drawHUD() {
            // HP Bar
            const hpBarX = 25 * currentScale; /* Increased X position */
            const hpBarY = 25 * currentScale; /* Increased Y position */
            const barWidth = 180 * currentScale; /* Wider bar */
            const barHeight = 25 * currentScale; /* Thicker bar */

            // Draw HP bar background
            gameCtx.fillStyle = "rgba(50, 50, 50, 0.7)"; /* Softer gray, slightly transparent */
            drawRect(gameCtx, hpBarX, hpBarY, barWidth, barHeight);
            gameCtx.fill();

            // Draw HP bar fill with gradient
            const hpFillWidth = (playerHP / playerMaxHP) * barWidth;
            const hpGradient = gameCtx.createLinearGradient(hpBarX, hpBarY, hpBarX + hpFillWidth, hpBarY);
            hpGradient.addColorStop(0, "#ff3333"); /* Brighter red */
            hpGradient.addColorStop(1, "#ff8888"); /* Lighter red */
            gameCtx.fillStyle = hpGradient;
            drawRect(gameCtx, hpBarX, hpBarY, hpFillWidth, barHeight);
            gameCtx.fill();
            
            gameCtx.fillStyle = "#e0e0e0"; /* Softer text color */
            gameCtx.font = `${20 * currentScale}px 'Press Start 2P'`; /* Slightly larger font */
            gameCtx.textAlign = "left";
            gameCtx.fillText(`HP: ${playerHP}/${playerMaxHP}`, hpBarX + barWidth + (15 * currentScale), hpBarY + barHeight / 2 + (8 * currentScale)); /* Adjusted spacing */

            const mercyBarX = hpBarX;
            let mercyBarY = hpBarY + barHeight + (10 * currentScale); /* Increased spacing */

            // Mercy Bar (only if an enemy is present)
            if (currentEnemy) {
                gameCtx.fillStyle = "rgba(50, 50, 50, 0.7)";
                drawRect(gameCtx, mercyBarX, mercyBarY, barWidth, barHeight); 
                gameCtx.fill();

                const mercyFillWidth = (currentEnemy.currentMercy / currentEnemy.mercyThreshold) * barWidth;
                const mercyGradient = gameCtx.createLinearGradient(mercyBarX, mercyBarY, mercyBarX + mercyFillWidth, mercyBarY);
                mercyGradient.addColorStop(0, "#00cc00");
                mercyGradient.addColorStop(1, "#66ff66");
                gameCtx.fillStyle = mercyGradient;
                drawRect(gameCtx, mercyBarX, mercyBarY, mercyFillWidth, barHeight);
                gameCtx.fill();

                gameCtx.fillStyle = "#e0e0e0";
                gameCtx.fillText(`MERCY: ${currentEnemy.currentMercy}/${currentEnemy.mercyThreshold}`, mercyBarX + barWidth + (15 * currentScale), mercyBarY + barHeight / 2 + (8 * currentScale));
            }

            // Determination Bar (always visible)
            const detBarX = hpBarX; 
            const detBarY = (currentEnemy ? mercyBarY + barHeight + (10 * currentScale) : hpBarY + barHeight + (10 * currentScale)); /* Increased spacing */
            
            gameCtx.fillStyle = "rgba(50, 50, 50, 0.7)";
            drawRect(gameCtx, detBarX, detBarY, barWidth, barHeight);
            gameCtx.fill();

            const detFillWidth = (player.determination / player.maxDetermination) * barWidth;
            const detGradient = gameCtx.createLinearGradient(detBarX, detBarY, detBarX + detFillWidth, detBarY);
            detGradient.addColorStop(0, "#ffcc00");
            detGradient.addColorStop(1, "#ffff66");
            gameCtx.fillStyle = detGradient;
            drawRect(gameCtx, detBarX, detBarY, detFillWidth, barHeight); 
            gameCtx.fill();

            gameCtx.fillStyle = "#e0e0e0";
            gameCtx.fillText(`DETER: ${player.determination}/${player.maxDetermination}`, detBarX + barWidth + (15 * currentScale), detBarY + barHeight / 2 + (8 * currentScale));


            // Dodge Box
            gameCtx.strokeStyle = "#b0b0b0"; /* Softer white */
            gameCtx.lineWidth = 3 * currentScale; /* Thicker border */
            gameCtx.strokeRect(DODGE_BOX_X_SCALED, DODGE_BOX_Y_SCALED, DODGE_BOX_WIDTH_SCALED, DODGE_BOX_HEIGHT_SCALED);
        }

        /**
         * Draws the current enemy sprite and name.
         */
        function drawEnemy() {
            if (currentEnemy) {
                // Apply subtle scale animation for enemy when hit or mercy gained
                let enemyScale = 1;
                if (currentEnemy.hitAnimationTimer > 0) {
                    enemyScale = 1 + Math.sin(currentEnemy.hitAnimationTimer * 0.5) * 0.08; // Pulsate on hit, slightly less intense
                    currentEnemy.hitAnimationTimer--;
                } else if (currentEnemy.mercyAnimationTimer > 0) {
                    enemyScale = 1 + Math.sin(currentEnemy.mercyAnimationTimer * 0.5) * 0.08; // Pulsate on mercy, slightly less intense
                    currentEnemy.mercyAnimationTimer--;
                }

                gameCtx.save(); // Save current canvas state
                gameCtx.translate(currentEnemy.x, currentEnemy.y); // Translate to enemy center
                gameCtx.scale(enemyScale, enemyScale); // Apply scale
                
                gameCtx.fillStyle = "#e0e0e0"; /* Softer text color */
                gameCtx.font = `${70 * currentScale}px 'Press Start 2P'`; /* Larger icon */
                gameCtx.textAlign = "center";
                const offsetX = screenShakeIntensity > 0 ? (Math.random() - 0.5) * screenShakeIntensity : 0;
                const offsetY = screenShakeIntensity > 0 ? (Math.random() - 0.5) * screenShakeIntensity : 0;

                const idleOffsetY = Math.sin(Date.now() * 0.005) * 5 * currentScale; // Scale idle animation, slightly more movement
                
                gameCtx.fillText(currentEnemy.sprite, offsetX, offsetY + idleOffsetY);
                gameCtx.font = `${32 * currentScale}px 'Press Start 2P'`; /* Larger name */
                gameCtx.fillText(currentEnemy.name, offsetX, (65 * currentScale) + offsetY + idleOffsetY); /* Adjusted spacing */
                gameCtx.textAlign = "left";

                gameCtx.fillStyle = "#ff3333"; /* Brighter red for HP */
                gameCtx.font = `${22 * currentScale}px 'Press Start 2P'`; /* Larger HP text */
                gameCtx.textAlign = "center";
                gameCtx.fillText(`HP: ${currentEnemy.hp}/${currentEnemy.maxHp}`, offsetX, (100 * currentScale) + offsetY + idleOffsetY); /* Adjusted spacing */
                gameCtx.textAlign = "left";

                gameCtx.restore(); // Restore canvas state
            }
        }

        // --- Attack Pattern Implementations ---
        /**
         * Spawns bullets randomly towards the player's general area.
         * @param {Object} pattern - The current attack pattern object.
         */
        function randomBulletsAttack(pattern) {
            if (currentEnemyAttackTimer % pattern.spawnFrequency === 0) {
                const angle = Math.random() * Math.PI * 2;
                const speed = (pattern.bulletSpeed + (Math.random() * 2 - 1)) * currentScale; // Scale bullet speed
                const startX = currentEnemy.x + Math.cos(angle) * (100 * currentScale);
                const startY = currentEnemy.y + Math.sin(angle) * (100 * currentScale);
                
                const targetX = DODGE_BOX_X_SCALED + Math.random() * DODGE_BOX_WIDTH_SCALED;
                const targetY = DODGE_BOX_Y_SCALED + Math.random() * DODGE_BOX_HEIGHT_SCALED;

                const dx = targetX - startX;
                const dy = targetY - startY;
                const distance = Math.sqrt(dx * dx + dy * dy);

                spawnBullet(
                    startX,
                    startY,
                    (dx / distance) * speed,
                    (dy / distance) * speed,
                    15,
                    pattern.bulletType,
                    pattern.bulletSprite
                );
            }
        }

        /**
         * Spawns bullets in a wave from top to bottom of the dodge box.
         * @param {Object} pattern - The current attack pattern object.
         */
        function waveBulletsAttack(pattern) {
            if (currentEnemyAttackTimer % pattern.spawnFrequency === 0) {
                const speed = pattern.bulletSpeed * currentScale; // Scale bullet speed
                const numBullets = 8;
                for (let i = 0; i < numBullets; i++) {
                    const bulletX = DODGE_BOX_X_SCALED + (i / (numBullets - 1)) * DODGE_BOX_WIDTH_SCALED;
                    spawnBullet(bulletX, DODGE_BOX_Y_SCALED, 0, speed, 15, pattern.bulletType, pattern.bulletSprite);
                }
            }
        }

        /**
         * Spawns bullets in a spiral pattern originating from the enemy.
         * @param {Object} pattern - The current attack pattern object.
         */
        function spiralBulletsAttack(pattern) {
            if (currentEnemyAttackTimer % pattern.spawnFrequency === 0) {
                const angle = (currentEnemyAttackTimer * 0.2) % (Math.PI * 2);
                const speed = pattern.bulletSpeed * currentScale; // Scale bullet speed
                const centerX = currentEnemy.x;
                const centerY = currentEnemy.y;
                
                spawnBullet(
                    centerX + Math.cos(angle) * (currentEnemyAttackTimer * 0.7 * currentScale), // Scale spiral radius
                    centerY + Math.sin(angle) * (currentEnemyAttackTimer * 0.7 * currentScale),
                    Math.cos(angle) * speed,
                    Math.sin(angle) * speed,
                    12,
                    pattern.bulletType,
                    pattern.bulletSprite
                );
            }
        }

        /**
         * Spawns bullets in an expanding circle from the center of the dodge box.
         * @param {Object} pattern - The current attack pattern object.
         */
        function expandingCircleAttack(pattern) {
            if (currentEnemyAttackTimer % pattern.spawnFrequency === 0) {
                const numBullets = 12;
                const initialRadius = 20 * currentScale; // Scale initial radius
                const speed = pattern.bulletSpeed * currentScale; // Scale bullet speed

                for (let i = 0; i < numBullets; i++) {
                    const angle = (i / numBullets) * Math.PI * 2;
                    const startX = DODGE_BOX_X_SCALED + DODGE_BOX_WIDTH_SCALED / 2 + Math.cos(angle) * initialRadius;
                    const startY = DODGE_BOX_Y_SCALED + DODGE_BOX_HEIGHT_SCALED / 2 + Math.sin(angle) * initialRadius;
                    
                    spawnBullet(
                        startX,
                        startY,
                        Math.cos(angle) * speed,
                        Math.sin(angle) * speed,
                        15,
                        pattern.bulletType,
                        pattern.bulletSprite
                    );
                }
            }
        }

        /**
         * Spawns bullets that target the player's current position.
         * @param {Object} pattern - The current attack pattern object.
         */
        function targetedBulletsAttack(pattern) {
            if (currentEnemyAttackTimer % pattern.spawnFrequency === 0) {
                const speed = (pattern.bulletSpeed + Math.random() * 2) * currentScale; // Scale bullet speed
                const startX = currentEnemy.x;
                const startY = currentEnemy.y;

                const dx = player.x - startX;
                const dy = player.y - startY;
                const distance = Math.sqrt(dx * dx + dy * dy);

                spawnBullet(
                    startX,
                    startY,
                    (dx / distance) * speed,
                    (dy / distance) * speed,
                    15,
                    pattern.bulletType,
                    pattern.sprite
                );
            }
        }

        /**
         * Spawns bullets in horizontal or vertical lines.
         * @param {Object} pattern - The current attack pattern object.
         */
        function lineBulletsAttack(pattern) {
            if (currentEnemyAttackTimer % pattern.spawnFrequency === 0) {
                const speed = pattern.bulletSpeed * currentScale; // Scale bullet speed
                const numBullets = 10;
                const isHorizontal = Math.random() > 0.5;

                if (isHorizontal) {
                    const startY = DODGE_BOX_Y_SCALED + Math.random() * DODGE_BOX_HEIGHT_SCALED;
                    for (let i = 0; i < numBullets; i++) {
                        const bulletX = DODGE_BOX_X_SCALED + (i / (numBullets - 1)) * DODGE_BOX_WIDTH_SCALED;
                        spawnBullet(bulletX, startY, 0, speed * (Math.random() > 0.5 ? 1 : -1), 15, pattern.bulletType, pattern.sprite);
                    }
                } else {
                    const startX = DODGE_BOX_X_SCALED + Math.random() * DODGE_BOX_WIDTH_SCALED;
                    for (let i = 0; i < numBullets; i++) {
                        const bulletY = DODGE_BOX_Y_SCALED + (i / (numBullets - 1)) * DODGE_BOX_HEIGHT_SCALED;
                        spawnBullet(startX, bulletY, speed * (Math.random() > 0.5 ? 1 : -1), 0, 15, pattern.bulletType, pattern.sprite);
                    }
                }
            }
        }

        /**
         * Calculates the number of attacks an enemy will perform in its turn
         * based on its current HP.
         * @param {Object} enemy - The current enemy object.
         * @returns {number} The number of attacks for this turn.
         */
        function calculateAttacksForTurn(enemy) {
            if (!enemy) return 1; // Default to 1 if no enemy

            const hpRatio = enemy.hp / enemy.maxHp;
            let attacks = enemy.baseAttacksPerTurn;

            // Increase attacks as HP decreases
            if (hpRatio <= 0.3) { // Below 30% HP
                attacks = enemy.maxAttacksPerTurn;
            } else if (hpRatio <= 0.6) { // Below 60% HP
                attacks = Math.min(enemy.maxAttacksPerTurn, enemy.baseAttacksPerTurn + 1);
            }
            // For bosses, maybe add another tier
            if (enemy.name === "Grumpy Golem") {
                if (hpRatio <= 0.15) { // Ultra low HP
                    attacks = Math.min(enemy.maxAttacksPerTurn, enemy.baseAttacksPerTurn + 2);
                } else if (hpRatio <= 0.4) { // Low HP
                    attacks = Math.min(enemy.maxAttacksPerTurn, enemy.baseAttacksPerTurn + 1);
                }
            }

            return attacks;
        }


        // --- Game State Functions ---

        /**
         * Sets the current game state and logs the transition.
         * @param {string} newState - The new state to transition to.
         */
        function setGameState(newState) {
            gameState = newState;
            console.log(`Game State changed to: ${newState}`);
        }

        /**
         * Displays the main game menu.
         */
        function showMainMenu() {
            setGameState("menu");
            gameMainMenu.style.display = 'flex'; // Ensure menu is visible
            gameDialogueBox.style.display = 'none';
            bulletTutorialBox.style.display = 'none';
        }

        /**
         * Hides the main game menu.
         */
        function hideMainMenu() {
            gameMainMenu.style.display = 'none'; 
        }

        /**
         * Contains the core logic for starting the game.
         * This function is called after the audio context is initiated.
         */
        function startGameLogic() {
            console.log("Starting game logic...");
            hideMainMenu();
            playerHP = playerMaxHP;
            player.determination = 0;
            enemiesSpared = 0;
            enemiesDefeated = 0; // Reset defeated count
            pacifistScore = 0;
            firstEncounter = true; // Reset for new game
            firstFightMinigame = true; // Reset for new game
            setGameState("intro");
            // Player position reset to center of scaled dodge box
            player.x = DODGE_BOX_X_SCALED + DODGE_BOX_WIDTH_SCALED / 2 - player.size / 2;
            player.y = DODGE_BOX_Y_SCALED + DODGE_BOX_HEIGHT_SCALED / 2 - player.size / 2;
            
            startIntroSequence();
        }

        /**
         * Initiates the game's introductory dialogue sequence.
         */
        function startIntroSequence() {
            console.log("Starting intro sequence...");
            showDialogue("You blink awake, your soul glowing softly in a dreamy, endless starfield. ‚ú® You are Doofy, the most determined little soul in the cosmos! (Psst! Move your MOUSE to guide your soul. Keep it safe inside the glowing white box!)", [
                { label: "Okay!", action: () => {
                    showDialogue("Today is a VERY important day! It's Quackers' birthday, and your quest is to spread friendship and joy across the galaxy! üéÇ\n\n(Hint: You can choose to ACT kindly to befriend monsters, or FIGHT if they're being super grumpy and need a little 'subduing'!)", [
                        { label: "Let's Go!", action: () => {
                            showBulletTutorial(); // Show bullet tutorial before first encounter
                        }}
                    ]);
                }}
            ]);
        }

        /**
         * Displays the bullet tutorial.
         */
        function showBulletTutorial() {
            setGameState("bullet_tutorial");
            gameDialogueBox.style.display = "none";
            bulletTutorialBox.style.display = "flex";
            player.color = "red"; // Default to red
            bullets = []; // Clear any existing bullets

            // Temporarily set up a small animation for the tutorial
            let tutorialBullet = { x: DODGE_BOX_X_SCALED + DODGE_BOX_WIDTH_SCALED / 2, y: DODGE_BOX_Y_SCALED + DODGE_BOX_HEIGHT_SCALED / 2, vx: 0, vy: 0, size: 20 * currentScale, type: "red", sprite: "‚ù§Ô∏è" };
            let tutorialPlayerX = player.x;
            let tutorialPlayerY = player.y;

            let tutorialPhase = 0; // 0: Red, 1: Blue, 2: Orange
            let tutorialTimer = 0;
            const tutorialPhaseDuration = 180; // 3 seconds per phase

            function runTutorialAnimation() {
                if (gameState !== "bullet_tutorial") return;

                // Update player position for tutorial (fixed to center for demonstration)
                player.x = DODGE_BOX_X_SCALED + DODGE_BOX_WIDTH_SCALED / 2 - player.size / 2;
                player.y = DODGE_BOX_Y_SCALED + DODGE_BOX_HEIGHT_SCALED / 2 - player.size / 2;

                gameCtx.clearRect(0, 0, gameCanvas.width, gameCanvas.height);
                drawStars();
                drawCosmicDust();
                drawHUD();
                drawHeart(player.x, player.y, player.size, player.color);

                tutorialTimer++;

                if (tutorialTimer > tutorialPhaseDuration) {
                    tutorialTimer = 0;
                    tutorialPhase = (tutorialPhase + 1) % 3; // Cycle through phases
                    bullets = []; // Clear bullets for new phase
                    player.isMoving = false; // Reset movement status for next phase
                }

                switch (tutorialPhase) {
                    case 0: // Red: Move to dodge
                        player.color = "red";
                        if (tutorialTimer % 30 === 0) {
                            const angle = Math.random() * Math.PI * 2;
                            const speed = 5 * currentScale;
                            spawnBullet(DODGE_BOX_X_SCALED + DODGE_BOX_WIDTH_SCALED / 2, DODGE_BOX_Y_SCALED + DODGE_BOX_HEIGHT_SCALED / 2,
                                Math.cos(angle) * speed, Math.sin(angle) * speed, 15, "red", "‚ù§Ô∏è");
                        }
                        break;
                    case 1: // Blue: Stay still to dodge
                        player.color = "blue";
                        if (tutorialTimer % 40 === 0) {
                            const angle = Math.random() * Math.PI * 2;
                            const speed = 4 * currentScale;
                            spawnBullet(DODGE_BOX_X_SCALED + DODGE_BOX_WIDTH_SCALED / 2, DODGE_BOX_Y_SCALED + DODGE_BOX_HEIGHT_SCALED / 2,
                                Math.cos(angle) * speed, Math.sin(angle) * speed, 15, "blue", "üíô");
                        }
                        break;
                    case 2: // Orange: Move to dodge
                        player.color = "orange";
                        if (tutorialTimer % 35 === 0) {
                            const angle = Math.random() * Math.PI * 2;
                            const speed = 6 * currentScale;
                            spawnBullet(DODGE_BOX_X_SCALED + DODGE_BOX_WIDTH_SCALED / 2, DODGE_BOX_Y_SCALED + DODGE_BOX_HEIGHT_SCALED / 2,
                                Math.cos(angle) * speed, Math.sin(angle) * speed, 15, "orange", "üß°");
                        }
                        break;
                }
                updateBullets();
                drawBullets();

                requestAnimationFrame(runTutorialAnimation);
            }
            runTutorialAnimation();

            tutorialContinueBtn.onclick = () => {
                buttonClickSound.triggerAttackRelease("C5", "16n");
                bulletTutorialBox.style.display = "none";
                gameDialogueBox.style.display = "none"; // Ensure dialogue box is hidden
                bullets = []; // Clear tutorial bullets
                player.color = "red"; // Reset player color
                isGamePausedForPopup = false; // Resume game
                startNextEncounter(); // Start the first encounter
            };
        }


        /**
         * Displays the player's turn options (ACT, ITEM, CHECK, FIGHT, SPARE, EXIT).
         */
        function showPlayerTurnOptions() {
            setGameState("player_turn_options");
            gameDialogueBox.style.display = "block";
            player.color = "red"; 

            const optionsButtons = [
                { label: "ACT", action: () => showActMenu(currentEnemy) },
                { label: "ITEM", action: () => showItemMenu() },
                { label: "CHECK", action: () => showCheckMenu(currentEnemy) },
                { label: "FIGHT", action: () => startFightMinigame() },
                { label: "DETERMINATION", action: () => showDeterminationMenu() } // New Determination button
            ];

            // Add SPARE option if mercy threshold is met AND currentEnemy exists
            if (currentEnemy && currentEnemy.currentMercy >= currentEnemy.mercyThreshold) {
                optionsButtons.splice(1, 0, { label: "SPARE", action: () => endEncounter("spared") }); // Insert SPARE after ACT
            }
            // Add DEFEAT option if enemy HP is 0 AND currentEnemy exists
            if (currentEnemy && currentEnemy.hp <= 0) {
                // If SPARE was added, it's at index 1, so DEFEAT goes after it at index 2.
                // If SPARE was NOT added, it's at index 1 (after ACT).
                const insertIndex = (currentEnemy && currentEnemy.currentMercy >= currentEnemy.mercyThreshold) ? 2 : 1;
                optionsButtons.splice(insertIndex, 0, { label: "SUBDUE", action: () => endEncounter("defeated") }); // Insert SUBDUE after ACT/SPARE
            }

            optionsButtons.push({ label: "EXIT GAME", action: () => exitGame() });

            showDialogue(`What's your next move, Doofy? The fate of Quackers' birthday party rests on your tiny soul!`, optionsButtons);
        }

        /**
         * Displays the Determination menu.
         */
        function showDeterminationMenu() {
            setGameState("determination_menu");
            player.color = "gold"; // Determination color
            const detButtons = [];

            // Shortened labels to fit better
            if (player.determination >= 10 && playerHP < playerMaxHP) {
                detButtons.push({ label: "Heal (10 DETER)", action: () => useDetermination("heal") });
            } else if (playerHP >= playerMaxHP) {
                detButtons.push({ label: "Heal (HP Full)", action: () => showCustomMessage("Your HP is already sparkling and full! No need to heal right now, Doofy!") || showDeterminationMenu() });
            } else {
                detButtons.push({ label: "Heal (Need 10 DETER)", action: () => showCustomMessage("Not enough Determination to heal! Keep fighting (or befriending) to gather more!") || showDeterminationMenu() });
            }

            if (player.determination >= 15 && bullets.length > 0) {
                detButtons.push({ label: "Clear Bullets (15 DETER)", action: () => useDetermination("clear_bullets") });
            } else if (bullets.length === 0) {
                detButtons.push({ label: "Clear Bullets (No Bullets)", action: () => showCustomMessage("Phew! No pesky bullets to clear right now, Doofy!") || showDeterminationMenu() });
            } else {
                detButtons.push({ label: "Clear Bullets (Need 15 DETER)", action: () => showCustomMessage("You need a little more Determination to make those bullets vanish, Doofy!") || showDeterminationMenu() });
            }

            if (player.determination >= 20 && !player.invincible) {
                detButtons.push({ label: "Invincibility (20 DETER)", action: () => useDetermination("invincibility") });
            } else if (player.invincible) {
                detButtons.push({ label: "Invincibility (Active)", action: () => showCustomMessage("You're already super invincible, Doofy! Go forth and be a sparkly shield!") || showDeterminationMenu() });
            } else {
                detButtons.push({ label: "Invincibility (Need 20 DETER)", action: () => showCustomMessage("Not quite enough Determination for temporary invincibility, Doofy! Keep pushing!") || showDeterminationMenu() });
            }

            detButtons.push({ label: "BACK", action: () => showPlayerTurnOptions() });
            showDialogue(`Your Determination shines bright, Doofy! Current: ${player.determination}/${player.maxDetermination}\nWhat powerful move will you unleash?`, detButtons);
        }

        /**
         * Uses Determination for a special ability.
         * @param {string} abilityType - The type of ability to use.
         */
        function useDetermination(abilityType) {
            let cost = 0;
            let message = "";
            let success = false;

            switch (abilityType) {
                case "heal":
                    cost = 10;
                    if (player.determination >= cost && playerHP < playerMaxHP) {
                        player.determination -= cost;
                        playerHP = Math.min(playerMaxHP, playerHP + 10);
                        message = "You feel a warm, fuzzy surge of energy! HP +10! You're ready to shine!";
                        spawnParticles(player.x, player.y, "üíñ", "pink");
                        healSound.triggerAttackRelease("C5", "8n");
                        success = true;
                    }
                    break;
                case "clear_bullets":
                    cost = 15;
                    if (player.determination >= cost && bullets.length > 0) {
                        player.determination -= cost;
                        bullets = []; // Clear all bullets
                        message = "POOF! All those pesky bullets just vanished into thin air! You're a bullet-busting hero!";
                        spawnParticles(DODGE_BOX_X_SCALED + DODGE_BOX_WIDTH_SCALED / 2, DODGE_BOX_Y_SCALED + DODGE_BOX_HEIGHT_SCALED / 2, "ÔøΩ", "cyan");
                        clearBulletsSound.triggerAttackRelease("C6", "8n");
                        success = true;
                    }
                    break;
                case "invincibility":
                    cost = 20;
                    if (player.determination >= cost && !player.invincible) {
                        player.determination -= cost;
                        player.invincible = true;
                        player.invincibilityTimer = 300; // 5 seconds of invincibility (60 frames/sec)
                        message = "WHOOSH! You are temporarily invincible! Go forth and defy gravity (and bullets)!";
                        spawnParticles(player.x, player.y, "üõ°Ô∏è", "yellow");
                        invincibilitySound.triggerAttackRelease("C7", "8n");
                        success = true;
                    }
                    break;
            }

            if (success) {
                showCustomMessage(message);
                // After using determination, return to player options
                setTimeout(() => showPlayerTurnOptions(), 1000); // Small delay for message to be read
            } else {
                // If not successful, the custom message is already handled by showDeterminationMenu
            }
        }


        /**
         * Starts the enemy's attack phase.
         */
        function startEnemyAttackPhase() {
            setGameState("enemy_attack_phase");
            gameDialogueBox.style.display = "none"; // Hide dialogue during attack
            bullets = []; // Clear any residual bullets
            currentEnemyAttackTimer = 0;

            // NEW: If this is the start of a fresh enemy turn, calculate total attacks
            if (currentAttackRound === 0) {
                totalAttacksThisTurn = calculateAttacksForTurn(currentEnemy);
                console.log(`${currentEnemy.name} will perform ${totalAttacksThisTurn} attacks this turn.`);
            }
            
            // Determine the attack phase based on enemy HP
            let phaseIndex = 0;
            if (currentEnemy.hp <= currentEnemy.maxHp * 0.3) { // Below 30% HP
                phaseIndex = 2;
                if (currentEnemy.name === "Grumpy Golem") triggerGlitch(null); // Golem gets glitchy at low HP
            } else if (currentEnemy.hp <= currentEnemy.maxHp * 0.6) { // Below 60% HP
                phaseIndex = 1;
            }

            // Select a random attack pattern from the determined phase
            const phasePatterns = currentEnemy.attackPatterns.filter(p => p.phase === phaseIndex);
            if (phasePatterns.length > 0) {
                const selectedPattern = randomFrom(phasePatterns);
                currentAttackDuration = selectedPattern.duration;
                currentAttackFlavorText = selectedPattern.flavor;
                player.color = selectedPattern.bulletType; // Set player soul color based on attack type
                currentEnemy.currentAttackPattern = selectedPattern; // Store the active pattern
            } else {
                console.warn(`No attack patterns found for enemy ${currentEnemy.name} in phase ${phaseIndex}. Transitioning to player turn options.`);
                // If no patterns for this phase, immediately end the enemy's turn
                currentAttackRound = 0; // Reset for next turn
                totalAttacksThisTurn = 0; // Reset
                showPlayerTurnOptions();
                return;
            }

            // Removed: Reset player position to center of scaled dodge box at start of attack phase
            // player.x = DODGE_BOX_X_SCALED + DODGE_BOX_WIDTH_SCALED / 2 - player.size / 2;
            // player.y = DODGE_BOX_Y_SCALED + DODGE_BOX_HEIGHT_SCALED / 2 - player.size / 2;
        }

        /**
         * Contains the core logic for starting the fight mini-game.
         * Separated to allow for pre-fight dialogue.
         */
        function proceedToFightMinigameLogic() {
            setGameState("fight_minigame");
            gameDialogueBox.style.display = "none";
            // Randomize sweet spot and critical spot offsets for this fight
            // These offsets are relative to the start of the fight bar
            // Ensure sweet spot fits within the bar
            currentSweetSpotOffset = Math.random() * (FIGHT_BAR_WIDTH_SCALED - SWEET_SPOT_WIDTH_SCALED);
            // Ensure critical spot fits within the sweet spot
            currentCriticalSpotOffset = Math.random() * (SWEET_SPOT_WIDTH_SCALED - CRITICAL_SPOT_WIDTH_SCALED);

            // Reset marker position for new game, scaled
            hitMarkerX = FIGHT_BAR_X_SCALED + FIGHT_BAR_WIDTH_SCALED / 2;
            hitMarkerDirection = Math.random() > 0.5 ? 1 : -1; // Random initial direction
            // Add click listener for the mini-game
            gameCanvas.addEventListener('mousedown', handleFightClick, { once: true });
        }

        /**
         * Starts the fight mini-game, with an optional tutorial for the first time.
         */
        function startFightMinigame() {
            if (firstFightMinigame) {
                showDialogue("Time to show 'em what you're made of, Doofy! To ATTACK: Click the bar when your YELLOW heart marker is in the MAGENTA 'sweet spot' for a good hit, or the super tiny LIME GREEN 'critical spot' for massive damage! Timing is EVERYTHING! Don't miss!", [
                    { label: "Got It!", action: () => {
                        firstFightMinigame = false; // Set flag to false after first hint
                        proceedToFightMinigameLogic();
                    }}
                ]);
            } else {
                proceedToFightMinigameLogic();
            }
        }

        /**
         * Handles click event for the fight mini-game.
         * @param {MouseEvent} e - The mouse event.
         */
        function handleFightClick(e) {
            if (gameState !== "fight_minigame") return;

            const rect = gameCanvas.getBoundingClientRect();
            const clickX = (e.clientX - rect.left) * (gameCanvas.width / rect.width);

            // Calculate current sweet spot and critical spot positions based on random offsets
            const sweetSpotStart = FIGHT_BAR_X_SCALED + currentSweetSpotOffset;
            const sweetSpotEnd = sweetSpotStart + SWEET_SPOT_WIDTH_SCALED; 
            const criticalSpotStart = sweetSpotStart + currentCriticalSpotOffset;
            const criticalSpotEnd = criticalSpotStart + CRITICAL_SPOT_WIDTH_SCALED;

            // The position of the moving heart marker
            const heartSizeForCollision = player.size * 1.5; // Use the same size as drawn
            const heartMarkerLeftEdge = hitMarkerX; // The x position of the heart's left edge
            const heartMarkerRightEdge = hitMarkerX + heartSizeForCollision;

            let damageDealt = 0;
            let hitMessage = "";
            let hitColor = "white";

            // Check for overlap between heart marker and hit zones
            if (
                (heartMarkerRightEdge >= criticalSpotStart && heartMarkerLeftEdge <= criticalSpotEnd) || // Marker overlaps critical start
                (heartMarkerLeftEdge <= criticalSpotEnd && heartMarkerRightEdge >= criticalSpotStart)    // Marker overlaps critical end
            ) {
                damageDealt = Math.floor(Math.random() * 2) + 5; // Critical hit: 5 or 6 damage
                hitMessage = "CRITICAL HIT! üí•";
                hitColor = "lime";
                screenShake(10, 15);
                attackHitSound.triggerAttackRelease("G5", "16n"); // High pitch for critical
            } else if (
                (heartMarkerRightEdge >= sweetSpotStart && heartMarkerLeftEdge <= sweetSpotEnd) || // Marker overlaps sweet start
                (heartMarkerLeftEdge <= sweetSpotEnd && heartMarkerRightEdge >= sweetSpotStart)    // Marker overlaps sweet end
            ) { 
                damageDealt = Math.floor(Math.random() * 2) + 3; // Sweet spot hit: 3 or 4 damage
                hitMessage = "GREAT HIT! ‚ú®";
                hitColor = "magenta";
                screenShake(7, 12);
                attackHitSound.triggerAttackRelease("E5", "16n"); // Medium pitch for sweet
            } else if (
                (heartMarkerRightEdge >= FIGHT_BAR_X_SCALED && heartMarkerLeftEdge <= FIGHT_BAR_X_SCALED + FIGHT_BAR_WIDTH_SCALED) // Marker within main bar
            ) {
                damageDealt = Math.floor(Math.random() * 2) + 1; // Normal hit: 1 or 2 damage
                hitMessage = "HIT! üëç";
                hitColor = "yellow";
                screenShake(3, 8);
                attackHitSound.triggerAttackRelease("C5", "16n"); // Low pitch for normal hit
            } else {
                damageDealt = 0; // Miss
                hitMessage = "MISS! ‚ùå";
                hitColor = "gray";
                attackHitSound.triggerAttackRelease("C3", "32n"); // Very low pitch for miss
            }

            // Spawn floating text for hit/miss
            spawnFloatingText(hitMarkerX, FIGHT_BAR_Y_SCALED - 20, hitMessage, hitColor);

            if (currentEnemy) {
                currentEnemy.hp = Math.max(0, currentEnemy.hp - damageDealt);
                currentEnemy.hitAnimationTimer = 30; // Start hit animation for enemy
                if (damageDealt > 0) {
                    player.determination = Math.min(player.maxDetermination, player.determination + Math.floor(damageDealt / 2) + 1); // Gain determination
                    // Chance to drop item on successful hit
                    if (Math.random() < 0.15) { // 15% chance to drop item on hit
                        const drop = randomFrom(possibleDrops);
                        addItemToInventory(drop.item);
                    }
                }
                
                if (currentEnemy.hp <= 0) {
                    setTimeout(() => {
                        endEncounter("defeated"); // Directly end encounter if defeated
                    }, 1000);
                } else {
                    // After a successful hit in the fight minigame, the enemy attacks back
                    setTimeout(() => {
                        startEnemyAttackPhase(); // Enemy attacks back
                    }, 1000); // Short delay to show message
                }
            }
        }

        /**
         * Starts the next enemy encounter or transitions to win screen if all enemies are spared/defeated.
         */
        function startNextEncounter() {
            if (enemiesSpared + enemiesDefeated >= totalEnemies) {
                setGameState("win");
                showWinScreen();
                return;
            }
            currentEnemy = enemies[enemiesSpared + enemiesDefeated]; // Get the next enemy based on total cleared
            // Reset enemy HP and mercy for new encounter
            currentEnemy.hp = currentEnemy.hp || currentEnemy.maxHp; // Ensure HP is set, default to max if undefined
            currentEnemy.currentMercy = 0; 
            currentEnemy.hitAnimationTimer = 0; // Reset animation timer
            currentEnemy.mercyAnimationTimer = 0; // Reset animation timer
            bullets = []; // Clear bullets from previous encounter
            particles = []; // Clear particles
            currentEnemyAttackTimer = 0;
            currentAttackIndex = 0;
            player.color = "red"; // Ensure player color is red at start of new encounter

            // Set enemy's current position based on scaled original position
            currentEnemy.x = currentEnemy.originalX * currentScale;
            currentEnemy.y = currentEnemy.originalY * currentScale;

            // Dialogue before attack phase
            setGameState("encounter_dialogue");
            
            triggerGlitch(() => {
                showDialogue(randomFrom(currentEnemy.dialogue), [
                    { label: "Continue", action: () => showPlayerTurnOptions() } 
                ]);
            });
        }

        /**
         * Displays the ACT menu for the current enemy.
         * @param {Object} enemy - The current enemy object.
         */
        function showActMenu(enemy) {
            setGameState("act_menu");
            player.color = "red"; // Soul is red in ACT menu
            const actButtons = Object.keys(enemy.actResponses).map(label => ({
                label: label,
                action: () => {
                    // Increase mercy, applying mercy charm bonus if active
                    const mercyGain = 2 + (player.mercyBoostActive ? player.mercyBoostValue : 0);
                    enemy.currentMercy = Math.min(enemy.mercyThreshold, enemy.currentMercy + mercyGain);
                    player.determination = Math.min(player.maxDetermination, player.determination + 5); // Gain determination
                    enemy.mercyAnimationTimer = 30; // Start mercy animation for enemy
                    spawnParticles(enemy.x, enemy.y, "üíñ"); // Particles from enemy

                    // Chance to drop item on ACT
                    if (Math.random() < 0.2) { // 20% chance to drop item on ACT
                        const drop = randomFrom(possibleDrops);
                        addItemToInventory(drop.item);
                    }
                    
                    lastActedLabel = label; // Store the label for post-mini-attack dialogue
                    startMiniAttackPhaseForAct(); // Trigger mini-attack after ACT
                }
            }));
            actButtons.push({ label: "BACK", action: () => showPlayerTurnOptions() }); // Option to go back to main options
            showDialogue(`How will you ACT towards the ${enemy.name.toUpperCase()}? Maybe a kind word will do the trick!`, actButtons);
        }

        /**
         * Starts a small, less intense attack phase after an ACT action.
         */
        function startMiniAttackPhaseForAct() {
            setGameState("enemy_mini_attack_phase");
            gameDialogueBox.style.display = "none"; // Hide dialogue during attack
            bullets = []; // Clear any residual bullets
            currentEnemyAttackTimer = 0;
            currentAttackIndex = 0; // Start with the first mini-attack pattern

            if (currentEnemy && currentEnemy.miniAttackPatterns && currentEnemy.miniAttackPatterns.length > 0) {
                // Select a random mini-attack pattern
                const selectedPattern = randomFrom(currentEnemy.miniAttackPatterns);
                
                // Calculate mercy factor: 1 at 0 mercy, 0 at max mercy
                const mercyFactor = 1 - (currentEnemy.currentMercy / currentEnemy.mercyThreshold);
                
                // Scale properties based on mercy factor
                // Speed: Faster at low mercy (mercyFactor close to 1), slower at high mercy (mercyFactor close to 0)
                selectedPattern.bulletSpeed = selectedPattern.baseSpeed * (0.5 + 0.5 * mercyFactor); // Min 50% speed
                // Spawn Frequency: More frequent at low mercy (mercyFactor close to 1), less frequent at high mercy (mercyFactor close to 0)
                // Note: Lower spawnFrequency means more bullets, so multiply by (1 + mercyFactor) to make it less frequent at high mercy
                // Ensure spawnFrequency is at least 1 to prevent division by zero or infinite loops
                selectedPattern.spawnFrequency = Math.max(1, Math.floor(selectedPattern.baseSpawnFrequency * (0.5 + 0.5 * (1 + mercyFactor))));
                // Duration: Longer at low mercy, shorter at high mercy
                selectedPattern.duration = Math.floor(selectedPattern.baseDuration * (0.5 + 0.5 * mercyFactor)); // Min 50% duration

                currentAttackDuration = selectedPattern.duration;
                
                // Select flavor text based on mercy
                // Higher mercy means higher index in miniAttackDialogue (more hesitant)
                const mercyDialogueIndex = Math.min(currentEnemy.miniAttackDialogue.length - 1, Math.floor((currentEnemy.currentMercy / currentEnemy.mercyThreshold) * (currentEnemy.miniAttackDialogue.length - 1)));
                currentAttackFlavorText = currentEnemy.miniAttackDialogue[mercyDialogueIndex];

                player.color = selectedPattern.bulletType; // Set player soul color
                currentEnemy.currentMiniAttackPattern = selectedPattern; // Store the active mini-attack pattern
            } else {
                console.warn("No mini-attack patterns found for current enemy, returning to player turn options.");
                // If no mini-attack, directly show the ACT response
                showActResponseAndOptions();
                return;
            }

            // Removed: Reset player position to center of scaled dodge box at start of attack phase
            // player.x = DODGE_BOX_X_SCALED + DODGE_BOX_WIDTH_SCALED / 2 - player.size / 2;
            // player.y = DODGE_BOX_Y_SCALED + DODGE_BOX_HEIGHT_SCALED / 2 - player.size / 2;
        }

        /**
         * Displays the ITEM menu.
         */
        function showItemMenu() {
            setGameState("item_menu");
            player.color = "red"; // Soul is red in ITEM menu
            
            // Filter to only show items with count > 0
            const availableItems = inventory.filter(item => item.count > 0);

            const itemButtons = availableItems.map((item, index) => ({
                label: `${item.name} x${item.count} (${item.type === 'heal' ? item.value + ' HP' : item.description})`,
                action: () => useItem(inventory.indexOf(item)) // Pass original index for removal
            }));

            if (availableItems.length === 0) {
                itemButtons.push({ label: "No Items! üòî", action: () => showCustomMessage("Your backpack is a bit empty right now, Doofy! Keep adventuring to find more goodies!") || showPlayerTurnOptions() });
            }

            itemButtons.push({ label: "BACK", action: () => showPlayerTurnOptions() });
            showDialogue("What magical item will you use to help you on your quest?", itemButtons);
        }

        /**
         * Uses an item from the inventory.
         * @param {number} index - The index of the item to use.
         */
        function useItem(index) {
            const item = inventory[index];
            if (!item || item.count <= 0) {
                showCustomMessage("Oops! That item seems to have vanished or you don't have any left!");
                showPlayerTurnOptions();
                return;
            }

            let message = "";
            let itemUsed = false;

            switch (item.type) {
                case "heal":
                    if (playerHP < playerMaxHP) {
                        playerHP = Math.min(playerMaxHP, playerHP + item.value);
                        message = `POOF! You used a ${item.name}! You feel all warm and fuzzy. Healed ${item.value} HP!`;
                        spawnParticles(player.x, player.y, "üíñ", "pink");
                        healSound.triggerAttackRelease("C5", "8n");
                        success = true;
                    } else {
                        message = "Your HP is already sparkling and full! Save that for when you really need it, Doofy!";
                    }
                    break;
                case "speed_boost":
                    if (player.speedMultiplier === 1) { // Only apply if not already boosted
                        player.speedMultiplier = item.value;
                        player.speedBoostTimer = item.duration;
                        message = `ZOOM! You chugged a ${item.name}! You're super speedy now!`;
                        spawnParticles(player.x, player.y, "üí®", "cyan");
                        speedBoostSound.triggerAttackRelease("G5", "8n");
                        itemUsed = true;
                    } else {
                        message = "You're already zipping around like a tiny comet! Speed boost is still active!";
                    }
                    break;
                case "mercy_boost":
                    if (!player.mercyBoostActive) {
                        player.mercyBoostActive = true;
                        player.mercyBoostValue = item.value;
                        message = `Your ${item.name} glows softly! You feel extra compassionate. Mercy gain increased for this encounter!`;
                        spawnParticles(player.x, player.y, "‚ú®", "green");
                        mercyBoostSound.triggerAttackRelease("A5", "8n");
                        itemUsed = true;
                    } else {
                        message = "Your Heartfelt Charm is already radiating kindness! No need for another one right now!";
                    }
                    break;
                case "bullet_clear":
                    if (bullets.length > 0) {
                        bullets = [];
                        message = `WHOOSH! You activated the ${item.name}! All those nasty bullets just vanished!`;
                        spawnParticles(DODGE_BOX_X_SCALED + DODGE_BOX_WIDTH_SCALED / 2, DODGE_BOX_Y_SCALED + DODGE_BOX_HEIGHT_SCALED / 2, "üåÄ", "cyan");
                        clearBulletsSound.triggerAttackRelease("C6", "8n");
                        itemUsed = true;
                    } else {
                        message = "Phew! No bullets to erase right now, Doofy! Save that power for a real bullet-storm!";
                    }
                    break;
            }

            if (itemUsed) {
                item.count--; // Decrement count
                if (item.count <= 0) {
                    inventory.splice(index, 1); // Remove item if count is 0 or less
                }
            }
            showCustomMessage(message);
            showPlayerTurnOptions(); // Return to main options after using item
        }

        /**
         * Displays the CHECK menu for the current enemy.
         * @param {Object} enemy - The current enemy object.
         */
        function showCheckMenu(enemy) {
            setGameState("check_menu");
            player.color = "red"; // Soul is red in CHECK menu
            // Update check description to show actual HP
            const updatedCheckDescription = enemy.checkDescription.replace("HP: ??", `HP: ${enemy.hp}`).replace("ATK: ??", "ATK: ??").replace("DEF: ??", "DEF: ??");
            showDialogue(`You check on the ${enemy.name.toUpperCase()}.\n\n${updatedCheckDescription}`, [
                { label: "BACK", action: () => showPlayerTurnOptions() }
            ]);
        }

        /**
         * Shows the appropriate dialogue after a mini-attack from an ACT action.
         */
        function showActResponseAndOptions() {
            // Defensive check: If currentEnemy is null, something went wrong or the encounter already ended.
            // In such a case, we should not proceed with ACT response logic.
            if (!currentEnemy) {
                console.warn("showActResponseAndOptions called with currentEnemy being null. This should not happen if the game flow is correct after a mini-attack. Skipping ACT response logic.");
                // Immediately transition to the next logical state, assuming the enemy was already defeated/spared
                if (enemiesSpared + enemiesDefeated >= totalEnemies) {
                    showWinScreen();
                } else {
                    startNextEncounter();
                }
                return; // Exit the function to prevent further errors
            }

            if (currentEnemy.currentMercy >= currentEnemy.mercyThreshold) {
                // Enemy is pacified, end the encounter
                endEncounter("spared"); // This will handle the "CONTINUE" button to next enemy/win screen
            } else {
                // Enemy is not yet pacified, show response and offer to go back to ACT menu
                const responseText = randomFrom(currentEnemy.actResponses[lastActedLabel]);
                showDialogue(responseText, [
                    { label: "Okay!", action: () => showActMenu(currentEnemy) } // Single "OK" button to return to ACT menu
                ]);
            }
        }

        /**
         * Ends the current encounter, updating scores and preparing for the next.
         * @param {string} howEnded - "spared" or "defeated".
         */
        function endEncounter(howEnded) {
            gameDialogueBox.style.display = "none";
            bullets = []; // Clear any remaining bullets
            particles = []; // Clear any remaining particles
            player.color = "red"; // Reset soul color to red
            player.speedMultiplier = 1; // Reset speed multiplier
            player.mercyBoostActive = false; // Reset mercy boost
            player.mercyBoostValue = 0;
            player.invincible = false; // Reset invincibility
            player.invincibilityTimer = 0;

            // Remove the fight click listener if it was active
            gameCanvas.removeEventListener('mousedown', handleFightClick);


            // Store currentEnemy locally before setting global currentEnemy to null
            const endedEnemy = currentEnemy;
            currentEnemy = null; // Set to null immediately to prevent further access issues

            // Chance to drop item when encounter ends (regardless of spared/defeated)
            if (Math.random() < 0.25) { // 25% chance to drop item on encounter end
                const drop = randomFrom(possibleDrops);
                addItemToInventory(drop.item);
            }

            if (howEnded === "spared") {
                enemiesSpared++;
                pacifistScore++; // Increment pacifist score
                mercySound.triggerAttackRelease("C6", "8n"); // Play mercy sound
                showDialogue(`${endedEnemy.name.toUpperCase()} IS PACIFIED BY YOUR KINDNESS! ‚ù§Ô∏è\n\n(Another friend made! You're a true friendship hero! Press CONTINUE to move on.)`, [
                    { label: "Continue", action: () => {
                        if (enemiesSpared + enemiesDefeated >= totalEnemies) {
                            showWinScreen(); // Go to win screen if all enemies cleared
                        } else {
                            startNextEncounter(); // Otherwise, next encounter
                        }
                    }}
                ]);
            } else if (howEnded === "defeated") {
                enemiesDefeated++;
                enemyDefeatSound.triggerAttackRelease("C3", "4n"); // Fixed typo here
                showDialogue(endedEnemy.defeatedDialogue + "\n\n(The party is safe... for now. Press CONTINUE to move on.)", [
                    { label: "Continue", action: () => {
                        if (enemiesSpared + enemiesDefeated >= totalEnemies) {
                            showWinScreen(); // Go to win screen if all enemies cleared
                        } else {
                            startNextEncounter(); // Otherwise, next encounter
                        }
                    }}
                ]);
            }
            // After ending the encounter, ensure the game state is set to a non-attack state
            // This prevents gameLoop from trying to continue attack logic on a null enemy
            setGameState("dialogue_after_encounter"); // A new state to indicate we are in post-encounter dialogue
        }

        /**
         * Displays the win screen with branching endings.
         */
        function showWinScreen() {
            gameDialogueBox.style.display = "block";
            player.color = "red"; // Reset soul color to red
            let endingMessage = "";
            if (pacifistScore === totalEnemies) {
                endingMessage = "üåü TRUE PACIFIST ENDING! üåü\nYOU'VE BEFRIENDED EVERY SINGLE MONSTER! QUACKERS IS SO PROUD, AND THE BIRTHDAY PARTY IS FULL OF NEW, HAPPY FACES! YOU'RE THE ULTIMATE FRIENDSHIP HERO! üéâ";
            } else if (enemiesDefeated === totalEnemies) {
                endingMessage = "üíÄ CONQUEROR ENDING! üíÄ\nYOU'VE SUBDUED EVERY SINGLE MONSTER! QUACKERS IS A BIT SCARED, HIDING BEHIND THE CAKE, BUT THE PARTY IS SAFE... FOR NOW. YOU'RE A TOUGH COOKIE, DOOFY!";
            }
            else {
                endingMessage = "‚ú® NEUTRAL ENDING! ‚ú®\nYOU'VE REACHED QUACKERS! HAPPY BIRTHDAY! üéâ\n\n(Your quest for friendship is complete! Some monsters are your pals, others... well, they're just taking a very long nap. A balanced approach, Doofy!)";
            }
            showDialogue(endingMessage, [
                { label: "Play Again?", action: () => location.reload() },
                { label: "Exit to Website", action: () => exitGame() }
            ]);
        }

        /**
         * Displays the game over screen.
         */
        function showGameOverScreen() {
            setGameState("game_over");
            gameDialogueBox.style.display = "block";
            player.color = "red"; // Reset soul color to red
            showDialogue("OH NO! Your soul flickered out! You fainted from too much cuteness (or maybe just too many bullets)! üíÄüí´\n\n(Don't worry, Doofy! Your determination lives on! You can always try again!)", [
                { label: "Retry", action: () => location.reload() },
                { label: "Exit to Website", action: () => exitGame() }
            ]);
        }

        /**
         * Exits the game and returns to the main website page.
         */
        function exitGame() {
            // Redirect to star.html
            window.location.href = 'star.html';
        }

        // --- Main Game Loop ---
        function gameLoop() {
            // Apply screen shake offset
            let shakeX = 0, shakeY = 0;
            if (screenShakeDuration > 0) {
                shakeX = (Math.random() - 0.5) * screenShakeIntensity;
                shakeY = (Math.random() - 0.5) * screenShakeIntensity;
                screenShakeDuration--;
            }
            gameCtx.translate(shakeX, shakeY); // Apply shake transform

            // Clear canvas at the beginning of each frame
            gameCtx.clearRect(0, 0, gameCanvas.width, gameCanvas.height);

            // Always draw stars in the background
            drawStars();
            updateCosmicDust(); // Update and draw cosmic dust
            drawCosmicDust();

            // Update player effects
            if (player.speedBoostTimer > 0) {
                player.speedBoostTimer--;
                if (player.speedBoostTimer === 0) {
                    player.speedMultiplier = 1; // Reset speed
                    spawnParticles(player.x, player.y, "üí®", "gray"); // Visual cue for end of boost
                }
            }
            if (player.invincibilityTimer > 0) {
                player.invincibilityTimer--;
                player.invincible = true; // Ensure invincibility is true
                if (player.invincibilityTimer % 10 < 5) { // Simple flicker effect
                    gameCtx.globalAlpha = 0.5;
                } else {
                    gameCtx.globalAlpha = 1;
                }
                if (player.invincibilityTimer === 0) {
                    player.invincible = false;
                    gameCtx.globalAlpha = 1; // Reset alpha
                    spawnParticles(player.x, player.y, "‚ú®", "white"); // Visual cue for end of invincibility
                }
            }

            // Only update game logic if not paused for a popup
            if (!isGamePausedForPopup) {
                // Update game logic and draw game elements based on current state
                switch (gameState) {
                    case "menu":
                        // Main menu is active, no game logic update on canvas beyond stars
                        break;
                    case "intro":
                    case "encounter_dialogue":
                    case "player_turn_options":
                    case "act_menu":
                    case "item_menu":
                    case "check_menu":
                    case "determination_menu": // New state
                    case "dialogue_after_encounter": // Added new state to handle post-encounter dialogue
                        // In dialogue/menu states, draw enemy and player (stationary)
                        drawEnemy();
                        updateParticles();
                        drawParticles();
                        drawHeart(player.x, player.y, player.size, player.color);
                        drawHUD(); // Ensure HUD is drawn in these states
                        break;
                    case "enemy_attack_phase":
                    case "enemy_mini_attack_phase": // Handle mini-attack phase here too
                        // Enemy movement (if applicable)
                        if (currentEnemy && currentEnemy.canMove) {
                            currentEnemy.x += Math.sin(currentEnemyAttackTimer * 0.05) * 0.5 * currentScale; // Scale movement
                            currentEnemy.y += Math.cos(currentEnemyAttackTimer * 0.03) * 0.3 * currentScale; // Scale movement
                            // Clamp enemy position to prevent going off screen
                            currentEnemy.x = Math.max(100 * currentScale, Math.min(gameCanvas.width - (100 * currentScale), currentEnemy.x));
                            currentEnemy.y = Math.max(50 * currentScale, Math.min(DODGE_BOX_Y_SCALED - (150 * currentScale), currentEnemy.y));
                        }

                        drawHeart(player.x, player.y, player.size, player.color);
                        updateParticles();
                        drawParticles();
                        drawEnemy(); // Draw enemy during attack
                        
                        // Display flavor text during attack
                        gameCtx.fillStyle = "#e0e0e0"; /* Softer text color */
                        gameCtx.font = `${18 * currentScale}px 'Press Start 2P'`; /* Scale font, slightly larger */
                        gameCtx.textAlign = "center";
                        gameCtx.fillText(currentAttackFlavorText, gameCanvas.width / 2, DODGE_BOX_Y_SCALED - (15 * currentScale)); /* Adjusted spacing */
                        gameCtx.textAlign = "left";

                        let activePattern;
                        if (gameState === "enemy_attack_phase") {
                            // Ensure currentEnemy and its attackPatterns exist before trying to access
                            if (currentEnemy && currentEnemy.currentAttackPattern) {
                                activePattern = currentEnemy.currentAttackPattern;
                            } else {
                                activePattern = null; // No active pattern if enemy or patterns are missing
                            }
                        } else if (gameState === "enemy_mini_attack_phase") {
                            activePattern = currentEnemy && currentEnemy.currentMiniAttackPattern ? currentEnemy.currentMiniAttackPattern : null;
                        } else {
                            activePattern = null; // Default to null if state is not attack or mini-attack
                        }

                        if (activePattern && currentEnemyAttackTimer < activePattern.duration) {
                            const attackFunctionName = activePattern.type + 'Attack';
                            if (typeof window[attackFunctionName] === 'function') {
                                window[attackFunctionName](activePattern);
                            } else {
                                console.warn(`Attack function '${attackFunctionName}' not found.`);
                            }
                            
                            updateBullets();
                            drawBullets();
                            checkCollisions();
                            currentEnemyAttackTimer++;
                        } else { // Attack (or mini-attack) is over
                            bullets = []; // Clear bullets
                            currentEnemyAttackTimer = 0; // Reset timer for next attack/phase

                            if (gameState === "enemy_attack_phase") {
                                currentAttackRound++; // Increment for main attacks
                                if (currentAttackRound < totalAttacksThisTurn) {
                                    // If more attacks are planned for this turn, start the next one
                                    startEnemyAttackPhase(); // This will pick a new random pattern for the current phase
                                } else {
                                    // All attacks for this turn are done, return to player options
                                    currentAttackRound = 0; // Reset for next enemy turn
                                    totalAttacksThisTurn = 0; // Reset
                                    setGameState("player_turn_options");
                                    showPlayerTurnOptions();
                                }
                            } else { // enemy_mini_attack_phase is over (from ACT)
                                // After mini-attack, show the ACT response and options
                                currentAttackIndex = 0; // Reset for next time startMiniAttackPhaseForAct is called
                                showActResponseAndOptions();
                            }
                        }
                        drawHUD();
                        break;
                    case "bullet_tutorial": // This state is handled by its own animation loop, which pauses gameLoop updates
                        // This case should ideally not be reached if isGamePausedForPopup is true when in bullet_tutorial
                        // But if it is, we still want to draw the static elements
                        drawHeart(player.x, player.y, player.size, player.color);
                        drawHUD();
                        // Bullets and particles for tutorial are updated/drawn by runTutorialAnimation
                        break;
                    case "fight_minigame":
                        drawEnemy();
                        drawHUD();
                        drawFightMinigame();
                        updateFightMinigame();
                        gameCtx.fillStyle = "#e0e0e0"; /* Softer text color */
                        gameCtx.font = `${22 * currentScale}px 'Press Start 2P'`; /* Slightly larger font */
                        gameCtx.textAlign = "left";
                        gameCtx.fillText("FIGHTING!", 35 * currentScale, 100 * currentScale); /* Adjusted position */
                        break;
                    case "game_over":
                    case "win":
                        break;
                }

                if (playerHP <= 0 && gameState !== "game_over") {
                    setGameState("game_over");
                    bullets = [];
                    particles = [];
                    setTimeout(() => {
                        showGameOverScreen();
                    }, 200);
                    return;
                }
                
                drawGlitch();
                updateFloatingTexts();
                drawFloatingTexts();
            } else {
                // If paused, still draw the current state but don't update game logic
                drawStars();
                drawCosmicDust();
                drawHUD();
                if (currentEnemy) { // Only draw enemy if one is active, even if paused
                    drawEnemy();
                }
                drawHeart(player.x, player.y, player.size, player.color);
                // No update for bullets/particles/floating texts if paused
            }

            gameCtx.translate(-shakeX, -shakeY);
            requestAnimationFrame(gameLoop);
        }

        // === Fight Mini-game Drawing and Updating ===
        function drawFightMinigame() {
            // Draw the main bar
            gameCtx.fillStyle = "rgba(50, 50, 50, 0.7)"; /* Softer gray, slightly transparent */
            gameCtx.fillRect(FIGHT_BAR_X_SCALED, FIGHT_BAR_Y_SCALED, FIGHT_BAR_WIDTH_SCALED, FIGHT_BAR_HEIGHT_SCALED);

            // Calculate current sweet spot and critical spot positions based on random offsets
            const sweetSpotX = FIGHT_BAR_X_SCALED + currentSweetSpotOffset;
            const criticalSpotX = sweetSpotX + currentCriticalSpotOffset;

            // Draw the sweet spot (magenta)
            gameCtx.fillStyle = "#ff00ff"; /* Brighter magenta */
            gameCtx.fillRect(sweetSpotX, FIGHT_BAR_Y_SCALED, SWEET_SPOT_WIDTH_SCALED, FIGHT_BAR_HEIGHT_SCALED);
            
            // Draw the critical hit spot (lime green)
            gameCtx.fillStyle = "#00ff00"; /* Brighter lime green */
            gameCtx.fillRect(criticalSpotX, FIGHT_BAR_Y_SCALED, CRITICAL_SPOT_WIDTH_SCALED, FIGHT_BAR_HEIGHT_SCALED);

            // Draw the moving player soul (heart) as the marker
            // Adjust x and y to center the heart on hitMarkerX
            const heartSize = player.size * 1.5; // Make the heart slightly larger to be visible
            const heartX = hitMarkerX; 
            const heartY = FIGHT_BAR_Y_SCALED + FIGHT_BAR_HEIGHT_SCALED / 2 - (heartSize / 2); // Center vertically
            drawHeart(heartX, heartY, heartSize, "yellow"); // Draw heart in yellow for the marker

            // Add a pulsating glow effect around the heart marker
            gameCtx.shadowBlur = Math.sin(Date.now() * 0.01) * 4 + 4; // Pulsating blur, slightly less intense
            gameCtx.shadowColor = "yellow"; // Heart's color
            // Re-draw the heart with shadow
            drawHeart(heartX, heartY, heartSize, "yellow");
            gameCtx.shadowBlur = 0; // Reset shadow
        }

        function updateFightMinigame() {
            // Ensure currentEnemy exists before accessing its properties
            if (!currentEnemy) {
                // If currentEnemy is null during fight minigame, something is wrong with state transition.
                // Revert to player turn options or next encounter if all enemies are done.
                console.warn("currentEnemy is null in updateFightMinigame. Transitioning to next state.");
                if (enemiesSpared + enemiesDefeated >= totalEnemies) {
                    showWinScreen();
                } else {
                    showPlayerTurnOptions(); // Go back to options
                }
                return;
            }

            // Calculate HP ratio for dynamic scaling
            const hpRatio = currentEnemy.hp / currentEnemy.maxHp;

            // Interpolate sweet spot width based on HP ratio
            const sweetSpotFactor = MIN_SWEET_SPOT_FACTOR + (MAX_SWEET_SPOT_FACTOR - MIN_SWEET_SPOT_FACTOR) * hpRatio;
            SWEET_SPOT_WIDTH_SCALED = ORIGINAL_SWEET_SPOT_WIDTH * currentScale * sweetSpotFactor;

            // Interpolate critical spot width based on HP ratio
            const criticalSpotFactor = MIN_CRITICAL_SPOT_FACTOR + (MAX_CRITICAL_SPOT_FACTOR - MIN_CRITICAL_SPOT_FACTOR) * hpRatio;
            CRITICAL_SPOT_WIDTH_SCALED = ORIGINAL_CRITICAL_SPOT_WIDTH * currentScale * criticalSpotFactor;

            // Interpolate marker speed based on HP ratio (faster when HP is low)
            const speedFactor = MIN_HIT_MARKER_SPEED_FACTOR + (MAX_HIT_MARKER_SPEED_FACTOR - MIN_HIT_MARKER_SPEED_FACTOR) * (1 - hpRatio);
            hitMarkerX += (HIT_MARKER_SPEED * currentScale * speedFactor) * hitMarkerDirection;

            // Reverse direction if hitting boundaries
            // The heart marker has a width (player.size * 1.5), so adjust boundary check
            const heartMarkerWidth = player.size * 1.5;
            if (hitMarkerX + heartMarkerWidth >= FIGHT_BAR_X_SCALED + FIGHT_BAR_WIDTH_SCALED || hitMarkerX <= FIGHT_BAR_X_SCALED) {
                hitMarkerDirection *= -1;
            }
        }


        // === Background Animation: Starfield ===
        let stars = [];
        function initStars() {
            stars = Array.from({ length: 150 }, () => ({
                x: Math.random() * ORIGINAL_CANVAS_WIDTH, // Store original positions
                y: Math.random() * ORIGINAL_CANVAS_HEIGHT,
                size: Math.random() * 2 + 1,
                speed: Math.random() * 0.5 + 0.3
            }));
            initCosmicDust();
        }

        function drawStars() {
            gameCtx.fillStyle = "#000";
            gameCtx.fillRect(0, 0, gameCanvas.width, gameCanvas.height); // Use scaled canvas dimensions

            stars.forEach(star => {
                gameCtx.fillStyle = "#e0e0e0"; /* Softer white for stars */
                gameCtx.beginPath();
                gameCtx.arc(star.x * currentScale, star.y * currentScale, star.size * currentScale, 0, Math.PI * 2); // Scale position and size
                gameCtx.fill();
                star.y += star.speed;
                if (star.y * currentScale > gameCanvas.height) { // Check against scaled height
                    star.y = 0;
                    star.x = Math.random() * ORIGINAL_CANVAS_WIDTH; // Reset to original width for new star
                }
            });
        }

        // === Cosmic Dust Background Effect ===
        function initCosmicDust() {
            cosmicDustParticles = Array.from({ length: 80 }, () => ({
                x: Math.random() * ORIGINAL_CANVAS_WIDTH,
                y: Math.random() * ORIGINAL_CANVAS_HEIGHT,
                size: Math.random() * 1.5 + 0.5,
                opacity: Math.random() * 0.6 + 0.2,
                speed: Math.random() * 0.3 + 0.15
            }));
        }

        function updateCosmicDust() {
            cosmicDustParticles.forEach(p => {
                p.y += p.speed;
                if (p.y * currentScale > gameCanvas.height) { // Check against scaled height
                    p.y = 0;
                    p.x = Math.random() * ORIGINAL_CANVAS_WIDTH; // Reset to original width
                }
            });
        }

        function drawCosmicDust() {
            cosmicDustParticles.forEach(p => {
                gameCtx.fillStyle = `rgba(255, 255, 255, ${p.opacity * (gameState === 'enemy_attack_phase' || gameState === 'enemy_mini_attack_phase' ? 1.2 : 0.8)})`; /* Slightly less opaque for subtlety */
                gameCtx.beginPath();
                gameCtx.arc(p.x * currentScale, p.y * currentScale, p.size * currentScale, 0, Math.PI * 2); // Scale position and size
                gameCtx.fill();
            });
        }

        // --- Tone.js Audio Setup (only for sound effects) ---
        // Player hit sound
        const playerHitSound = new Tone.MembraneSynth({
            pitchDecay: 0.05,
            octaves: 8,
            envelope: {
                attack: 0.001,
                decay: 0.4,
                sustain: 0.01,
                release: 0.6,
                attackCurve: "exponential"
            },
            oscillator: {
                type: "sine"
            },
            noise: {
                type: "pink"
            },
            volume: -10 // Adjust volume
        }).toDestination();

        // Button click sound
        const buttonClickSound = new Tone.Synth({
            oscillator: {
                type: "triangle"
            },
            envelope: {
                attack: 0.005,
                decay: 0.1,
                sustain: 0.01,
                release: 0.1
            },
            volume: -15
        }).toDestination();

        // Attack hit sound (fight minigame)
        const attackHitSound = new Tone.Synth({
            oscillator: {
                type: "sine"
            },
            envelope: {
                attack: 0.001,
                decay: 0.2,
                sustain: 0.01,
                release: 0.3
            },
            volume: -12
        }).toDestination();

        // Enemy defeat sound
        const enemyDefeatSound = new Tone.Synth({
            oscillator: {
                type: "square"
            },
            envelope: {
                attack: 0.01,
                decay: 0.5,
                sustain: 0.1,
                release: 1
            },
            volume: -8
        }).toDestination();

        // Mercy/Spare sound
        const mercySound = new Tone.Synth({
            oscillator: {
                type: "triangle"
            },
            envelope: {
                attack: 0.01,
                decay: 0.3,
                sustain: 0.05,
                release: 0.5
            },
            volume: -10
        }).toDestination();

        // Typing sound
        const typingSound = new Tone.Synth({
            oscillator: {
                type: "sine"
            },
            envelope: {
                attack: 0.001,
                decay: 0.05,
                sustain: 0.01,
                release: 0.05
            },
            volume: -20
        }).toDestination();

        // New sounds for Determination abilities
        const healSound = new Tone.Synth({
            oscillator: { type: "sine" },
            envelope: { attack: 0.01, decay: 0.2, sustain: 0.1, release: 0.3 },
            volume: -10
        }).toDestination();

        const clearBulletsSound = new Tone.NoiseSynth({
            noise: { type: "white" },
            envelope: { attack: 0.001, decay: 0.1, sustain: 0.01, release: 0.2 },
            volume: -10
        }).toDestination();

        const invincibilitySound = new Tone.Synth({
            oscillator: { type: "triangle" },
            envelope: { attack: 0.01, decay: 0.3, sustain: 0.1, release: 0.5 },
            volume: -8
        }).toDestination();

        // New sounds for Inventory items
        const speedBoostSound = new Tone.Synth({
            oscillator: { type: "sawtooth" },
            envelope: { attack: 0.005, decay: 0.1, sustain: 0.05, release: 0.2 },
            volume: -12
        }).toDestination();

        const mercyBoostSound = new Tone.Synth({
            oscillator: { type: "square" },
            envelope: { attack: 0.005, decay: 0.15, sustain: 0.05, release: 0.25 },
            volume: -12
        }).toDestination();

        const itemPickupSound = new Tone.Synth({
            oscillator: { type: "fmsine", modulationIndex: 5 },
            envelope: { attack: 0.001, decay: 0.2, sustain: 0.05, release: 0.1 },
            volume: -10
        }).toDestination();


        // --- Canvas Resizing Logic ---
        function resizeCanvas() {
            const availableWidth = window.innerWidth;
            const availableHeight = window.innerHeight;

            // Calculate scale based on the smaller dimension to fit within the screen
            currentScale = Math.min(availableWidth / ORIGINAL_CANVAS_WIDTH, availableHeight / ORIGINAL_CANVAS_HEIGHT);

            // Apply scale to canvas dimensions
            gameCanvas.width = ORIGINAL_CANVAS_WIDTH * currentScale;
            gameCanvas.height = ORIGINAL_CANVAS_HEIGHT * currentScale;

            // Recalculate scaled dodge box dimensions and positions
            DODGE_BOX_WIDTH_SCALED = ORIGINAL_DODGE_BOX_WIDTH * currentScale;
            DODGE_BOX_HEIGHT_SCALED = ORIGINAL_DODGE_BOX_HEIGHT * currentScale;
            DODGE_BOX_X_SCALED = (gameCanvas.width - DODGE_BOX_WIDTH_SCALED) / 2;
            DODGE_BOX_Y_SCALED = gameCanvas.height - DODGE_BOX_HEIGHT_SCALED - (ORIGINAL_DODGE_BOX_OFFSET_Y * currentScale);

            // Recalculate scaled fight bar dimensions and positions
            FIGHT_BAR_WIDTH_SCALED = ORIGINAL_FIGHT_BAR_WIDTH * currentScale;
            FIGHT_BAR_HEIGHT_SCALED = ORIGINAL_FIGHT_BAR_HEIGHT * currentScale;
            FIGHT_BAR_X_SCALED = DODGE_BOX_X_SCALED + (DODGE_BOX_WIDTH_SCALED - FIGHT_BAR_WIDTH_SCALED) / 2; // Centered horizontally in dodge box
            FIGHT_BAR_Y_SCALED = DODGE_BOX_Y_SCALED + (DODGE_BOX_HEIGHT_SCALED - FIGHT_BAR_HEIGHT_SCALED) / 2; // Centered vertically in dodge box

            // Sweet and Critical spot widths will be dynamically calculated in updateFightMinigame
            // Initialize them here to their max values (for when enemy is full HP)
            SWEET_SPOT_WIDTH_SCALED = ORIGINAL_SWEET_SPOT_WIDTH * currentScale * MAX_SWEET_SPOT_FACTOR;
            CRITICAL_SPOT_WIDTH_SCALED = ORIGINAL_CRITICAL_SPOT_WIDTH * currentScale * MAX_CRITICAL_SPOT_FACTOR;

            // Adjust player size and position to center of the *scaled* dodge box
            player.size = player.originalSize * currentScale;
            player.x = DODGE_BOX_X_SCALED + DODGE_BOX_WIDTH_SCALED / 2 - player.size / 2;
            player.y = DODGE_BOX_Y_SCALED + DODGE_BOX_HEIGHT_SCALED / 2 - player.size / 2;

            // Adjust enemy positions (if needed, or they can dynamically adjust in drawEnemy)
            enemies.forEach(enemy => {
                enemy.x = enemy.originalX * currentScale;
                enemy.y = enemy.originalY * currentScale;
                // Add new properties for animation timers
                enemy.hitAnimationTimer = 0; 
                enemy.mercyAnimationTimer = 0;
                // Add phase property to attack patterns
                enemy.attackPatterns.forEach((pattern, index) => {
                    if (enemy.name === "Grumpy Golem") { // Boss phases
                        if (index < 4) pattern.phase = 0; // First 4 attacks are phase 0
                        else if (index < 8) pattern.phase = 1; // Next 4 are phase 1
                        else pattern.phase = 2; // Remaining are phase 2
                    } else { // Regular enemy has 3 phases, split evenly
                        if (index < enemy.attackPatterns.length / 3) pattern.phase = 0;
                        else if (index < (enemy.attackPatterns.length / 3) * 2) pattern.phase = 1;
                        else pattern.phase = 2;
                    }
                });
            });

            // Adjust hit marker position for fight minigame
            hitMarkerX = FIGHT_BAR_X_SCALED + FIGHT_BAR_WIDTH_SCALED / 2;
        }

        window.addEventListener('resize', resizeCanvas);


        // --- Event Listeners for Game Menu ---
        menuPlayButton.addEventListener('click', () => {
            buttonClickSound.triggerAttackRelease("C5", "16n"); // Play sound on menu button click
            // Start Tone.js AudioContext on user gesture
            Tone.start().then(() => {
                startGameLogic(); // Proceed with game start logic
            }).catch(e => {
                console.error("Failed to start Tone.js AudioContext:", e);
                // Even if audio fails, try to start the game
                startGameLogic(); 
            });
        });
        menuOptionsButton.addEventListener('click', () => {
            buttonClickSound.triggerAttackRelease("C5", "16n");
            showCustomMessage("Oops! Doofy was so excited about making the game playable, he totally forgot to add options! Maybe next update? Or maybe his game is just perfect as is! üòâ");
        });
        menuCreditsButton.addEventListener('click', () => {
            buttonClickSound.triggerAttackRelease("C5", "16n");
            showCustomMessage("CREDITS:\nGame Concept & Code: Doofy (with a little help from a friendly AI!)\nInspiration: The legendary UNDERTALE by Toby Fox (thank you for the magic!)\nSpecial Thanks: Quackers (for being the best birthday duck ever!)\nAnd YOU, for playing! You're awesome! üéâ");
        });
        menuExitButton.addEventListener('click', () => {
            buttonClickSound.triggerAttackRelease("C5", "16n");
            exitGame();
        });

        // --- Initial Setup on Page Load ---
        window.onload = function() {
            resizeCanvas(); // Initial sizing of the canvas and game elements
            initStars(); // Initialize stars for the menu background
            
            showMainMenu(); // Show the main menu first
            gameLoop(); // Start the game loop for rendering
        };

    </script>
</body>
</html>
